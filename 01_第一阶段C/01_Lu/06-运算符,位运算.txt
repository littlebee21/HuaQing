1.复习
	[1] 基本数据类型 -- 浮点型 
		(1) 数据类型
			单精度		float型
			双精度		double型
			长双精度	long double型
		(2) 浮点型数据的表示  
			1) 小数形式 
			2) 指数形式
				aen  或  aEn   // a * 10^n 
		(3) 浮点型数据在内存中的存储方式
			1) IEEE 754  
				任意的二进制浮点数V，以表示成下面的形式：
				v = (-1)^s * M * 2^e
			2) 单精度 float  32bit
				|s  1bit| |e + 127  8bit| |f  23bit|
			3) 双精度 double 64bit 
				|s  1bit| |e + 1023 11bit| |f 52bit|
		(4)	不同类型浮点数的取值范围(32bit机器)	
			类型			位数	有效位数	取值范围
			float			32位	6~7位		10^-38 ~ 10^38           
			double			64位	15~16位		10^-308~10^308
			long double		96位	18~19位		10^-4932~10^4932
		(5) printf 函数对应的格式说明符  
			float  	%f  %e  
			double  %lf  %le  %f  %e  
			long double  %Lf  %Le
		(6) 浮点数的溢出   
			1) 上溢   试图存储一个绝对值非常大的值，如果超过其范围则导致溢出	inf 
			2) 下溢	  试图存储一个绝对值非常小的值，如果超过其精度则导致溢出	0.0000
	
	[2] 基本数据类型 -- 字符型
		(1) 数据类型   
			char 				1byte
			unsigned char 		1byte   
		(2) ASCII 码 
			目前大部分系统采用美国信息交换标准代码ASCII码（American Standard Code for Information Interchange）字符集。
			存储字符时都会被转换成对应的ascii码。
			中文编码 (GB2312)			
		(3) 字符常量 
			'a'
		(4) 字符变量
			字符型数据可以看成长度位8bit的整型数据
			例如，char c = '?';
		(5)	取值范围
			类型			位数	取值范围
			[signed] char	8位		-128 ~ 127
			[unsigned]char	8位		0 ~ 255
		(6) 转义字符 
			转义字符具有特殊的含义，不同于字符原有的意义，故称”转义”字符。例如，’\n’就是一个转义字符，
			其意义是“回车换行”
	
	[3] gdb 软件调试工具
		(1) gcc 需要添加 -g  
		(2) gdb 程序名 
		(3) gdb 常用指令  
			l  显示代码  
			b  添加断点 
			r  运行代码 
			n  单步运行  
			p  查看变量的内容或地址 
			q  退出  
			x  查看内存
				命令格式：x/nfu <addr>
				n : 表示要显示的内存单元个数
				f : 表示显示方式, 可取如下值
					x 按十六进制格式显示变量。
					d 按十进制格式显示变量。
					u 按十进制格式显示无符号整型。
					o 按八进制格式显示变量。
					t 按二进制格式显示变量。
					a 按十六进制格式显示变量。
					i 指令地址格式
					c 按字符格式显示变量。
					f 按浮点数格式显示变量。
				u表示一个地址单元的长度，与n一起表示显示的地址长度
					b表示单字节，
					h表示双字节，
					w表示四字节，
					g表示八字节
	
	[4]	数据类型间的转换 
		(1) 隐式类型转换 
				在有多种数据类型混合计算的时候，若未人为控制类型，系统会自动进行类型转换。
			转换的规则是：存储长度较短的转换成存储长度较长的，且不丢失数据。
		(2) 赋值转换
			如果赋值运算符两侧数据类型不一致，则在赋值时会发生赋值类型转换
			
			1) 浮点型数据赋值给整型变量时  
				只保留正数部分，小数部分被截断 
			2) 双精度的数据赋值给单精度变量时 
				只保留6-7位的有效数字，其余部分会被截断
			3) 长度较长的整型数据赋值给长度较短的整型变量  
				只保留地位有效数字，高位被舍去
			4) 长度较短的整型数据赋值给长度较长的整型变量  
				unsigned   高位自动补0 
				signed     符号位为0	高位补0 
						   符号位为1	高位补1
						   
			总结：类型升级通常不会有什么问题，但是类型降级却会带来不少问题。
		(3) 强制类型转换
			强制类型转换：人为地将某类型转换为另一类型
		强制类型转换符: ()
			(类型名) 表达式；
		eg: 
			float a = (int) 3.14;
			
	[5] 运算符 & 表达式  
		(1) 基本概念 
			1) 运算符 & 操作数
				C语言中用于告诉程序执行特殊算术或逻辑操作的符号称为运算符，
				运算的对象称为操作数。
			2) 表达式   
				用运算符和括号将操作数连接起来的符合C语言语法规则的句子称为表达式。
			3) 运算符类型  
				a. 操作数的数目分类  
					单目运算符   '+', '-'
					双目运算符 
					三目运算符
				b. 运算符的功能类型分类 
					算术运算符  
					赋值运算符 
					逻辑运算符 
					关系运算符 
					条件运算符  
					逗号运算符  
					位运算符
			4) 结合方向  
				a. 自左向右结合(左结合性)
				a. 自右向左结合(右结合性)		
			5) 优先级
				C语言中运算符有优先级，从高到低分为15级（不同书籍划分方式不同，级数不同，这里采用百度百科划分方式）;
			1级优先级最高，15级最低。
			
				简单记就是：！ > 算术运算符 > 关系运算符 > 逻辑运算符(&& > ||) > 赋值运算符
				
				注意： 同一优先级的运算符，结合次序由结合方向所决定。
		
		(2) 算术运算符  
			1) 四则运算，求模运算 
				+ , - , *, /, %  
				结合性：自左至右
				优先级：+和-：4级。*和/和%：3级
				
				注意:  
				①　C语言中，若相除2个数都是整数，则计算/时只取商，余数部分被舍去。
				②　	% 的操作数必须是整数
			
			2) 正,负运算符
				符号及含义：+（正数） -（负数）
				数目：单目运算符
				结合性：自右至左
				优先级：2级
				使用方法：+表达式 或 -表达式。
				
			3) 自增 & 自减运算符  
				符号及含义：++（自增1） --（自减1）
				数目：单目运算符
				结合性：自左至右 或 自右至左（取决于运算符位置）
				优先级：2级
				使用方法：
				自增；变量++ 或 ++变量。如a++ 或 ++a
				自减：变量-- 或 --变量。如b-- 或 --b
				
				注意：
				①　	自增或自减运算符仅用于变量，不能用于常量或表达式
				②　	注意++/--运算符与+/-（正数/负数运算符）是同等优先级。当这两个运算符一起使用时，是右结合性。即--a++ <---等价于---> --(a++);
				③　	自增或自减运算符可用在操作数之前，也可以放在其后，这两种用法稍有区别：
					运算符在操作数前时：
				C语言在引用操作数之前那就先执行加1或减1，例如：j = ++i;其执行过程是，先将变量i+1,再将计算结果赋给j。
					运算符在操作数后时：
				C语言先引用操作数的值，然后再进行加1或减1, 例如：j= i--;其执行过程是，先将变量i的值赋值给j;再执行将变量i-1。

	[6] 作业 
		作业1：求双精度浮点数123.125(十进制)在计算机中的表示	(先自己计算再使用gdb调试工具验证)	
				123.125 = 111 1011.001 = 1.11101100100 * 2^6 = (-1)^0 *　1.11101100100 * 2^6 ;
				s = 0;
				f = 0.11101100100
				e = 6
				
				|0| |10000000101| |11101100100000....|
				
				 0	 10000000101   1110110010000000000000000000000000000000000000000000
				 
		作业2:从键盘输入5个学生的成绩（整数），要求输出总成绩（整数）和平均成绩（小数）
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				int score;
				int sum = 0;
				float average = 0.0;

				printf("请输入学生的成绩 :");
				scanf("%d", &score);
				sum = sum + score;
				
				printf("请输入学生的成绩 :");
				scanf("%d", &score);
				sum = sum + score;

				printf("请输入学生的成绩 :");
				scanf("%d", &score);
				sum = sum + score;

				printf("请输入学生的成绩 :");
				scanf("%d", &score);
				sum = sum + score;

				printf("请输入学生的成绩 :");
				scanf("%d", &score);
				sum = sum + score;

				average = (float) sum / 5;
				printf("总成绩 : %d\n", sum);
				printf("平均成绩 : %f\n", average);
				return 0;
			}

====================================================================================================================================
1.运算符  
	[1] 关系运算符
		符号及含义：>（大于） <（小于） >=（大于等于） <=（小于等于） ==（判等） !=（不等）
		数目：双目运算符
		结合性：自左至右
		优先级：> < >= <=：6级。==和!=：7级
		使用方法：表达式 运算符 表达式。如3<5，a==7等 
	注意: 
		①　	关系运算符的操作数可以是变量、常量和表达式
		②　	关系表达式的的值是一个逻辑值：
			关系成立，即为真，结果为1；关系不成立，即为假，结果为0
		③　	注意区分判断两个表达式相等的运算符是==，与=（赋值运算符）
		
		逻辑真值和逻辑假值在c里是如何表达的？
			0 表示逻辑假 ：如0、0.0、\0、NULL
			非0表示逻辑真：而且非零不一定是整数，可以是任何类型
		
		练习：输入以下程序，查看输出结果并思考为什么？
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				int a = 3; 

				if (4 > a > 2) {
					printf("a = %d\n", a);
				} else {
					printf("error\n");
				}
				
				return 0;
			}

	[2] 逻辑运算符
		(1) 基础用法  
			逻辑运算符用于，对包含关系运算符的表达式进行逻辑上的合并或取非。
			符号及含义：&&（逻辑与） ||（逻辑或） !（逻辑非）
			数目：!为单目运算符，&&和||为双目运算符
			结合性：!为自右至左，&&和||为自左至右
			优先级：!：2级、&&：11级、||：12级
		
			使用方法：
			&&和||：表达式 运算符 表达式。如：a && b、a || b
			!：!表达式。如!a
			
			注意：
			①　	逻辑与：当且仅当两个表达式都为真时，则计算结果为真。否则为假
			②　	逻辑或：当且仅当两个表达式都为假时，则计算结果为假。否则为真
			③　	逻辑非：当原表达式为真时，计算结果为假；当原表达式为假时，计算结果为真
			④　	使用逻辑运算符的表达式结果为真(1)或假(0)；

		(2) 逻辑运算符短路现象
			当多个逻辑运算符连续使用的时候，会出现逻辑运算符短路的情况		
			1) 逻辑与（&&）运算符短路
				表达式1 && 表达式2 && 表达式3
				当表达式1是真时，才会去判断表达式2的真/假。否则，如果表达式1是假，则之后的都不会进行运算。
				当表达式2是真时，才会去判断表达式3的真/假。否则，如果表达式2是假，则之后的都不会进行运算。
			示例：
				int a=0,b=1,c=2,d;
				d = a++ && b-- && ++c;
				结果：
					a = 1,
					b = 1,
					c = 2,
					d = 0;
				分析：
					①　	首先会计算a++，计算a++会首先取出a的值，此时a的值是0
					②　	因为此时a的值是0，表达式1（a++）的位置是假，发生短路，后面的表达式2（b--）和表达式3（++c）都不会进行运算，此时返回假（0），赋值给d
					③　	执行a++（a的值加1）

			2) 逻辑或（||）运算符短路
				表达式1 || 表达式2 || 表达式3
				说明:
					当表达式1是真时，跳过判断表达式2和表达式3，直接返回真；
					当表达式1是假时，才去判断表达式2的真/假
					当表达式2是真时，跳过判断表达式3，直接返回真；
					当表达式2是假时，才去判断表达式3的真/假
				示例：
					int a=0,b=1,c=2,d;
					d = a++ || b-- || ++c;
					
					结果：
						a = 1,
						b = 0,
						c = 2,
						d = 1;
				
				分析：
					①　	首先会计算a++，计算a++会首先取出a的值，此时a的值是0
					②　	因为此时a的值是0，表达式1（a++）的位置是假，需要判断表达式2（b--）的值
					③　	计算b--，首先取出b的值，此时b的值是1
					④　	因为此时b的值是1，表达式2（b--）的位置是真，发生短路，无需判断表达式3（++c）的真/假，此时返回真（1），赋值给d
					⑤　	执行a++（a的值加1）和b--（b的值减1）
			
				练习1：如若将以上示例改写成下列形式，程序的执行结果是什么？先猜想结果，再上机验证
					int a=0,b=1,c=2,d;
					d = a++ || b-- && ++c; // d = a++ || (b-- && ++c);
					结果：
							a = 1,
							b = 0,
							c = 3,
							d = 1;
				练习2：如若将以上示例改写成下列形式，程序的执行结果是什么？先猜想结果，再上机验证
					int a=1,b=2,c=3,d;
					d = a++ || b-- && ++c; // d = a++ || (b-- && ++c);
					结果：
							a = 2,
							b = 2,
							c = 3,
							d = 1;
					注意：这里要特别注意&&的运算优先级比||高。运算优先级高并不代表会先运算，而是代表先与操作数结合。
				而整个算式还是按照自左至右顺序计算。
			
				作业: 设int a=3,b=4,c=5,d;
					分别求出下列表达式的d的值（即判断此表达式真假）先猜想结果，再上机验证
					1）d = a+b>c && b==c
					2）d = a || b+c && b-c
					3）d = !(a>b) && !c || 1
					4）d = !(x=a)&&(y=b)&&0（x和y均为int型，求出x和y的值）
					5）d = !(a+b)+c-1 && b+c/2.

	[3] 条件运算符			
		符号及含义：?:（判断?前表达式是否成立，若成立取:前表达式，否则取:后表达式）	
		数目：三目运算符（C语言中唯一的三目运算符）
		结合性：自右至左
		优先级：13级
		使用方法：表达式1?表达式2:表达式3。//先判断表达式1是否成立，若成立取表达式2，否则取表达式3。
		
		示例: 
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				int max, a, b;

				scanf("%d%d", &a, &b);
				max = a > b ? a : b;

				printf("max = %d\n", max);
				
				return 0;
			}
		练习：读以下程序，猜想输出的结果，再执行程序检验自己的猜想
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				int a = 2, b = 3;

				printf("%d\n", --a == b++ ? a++ : b++);
				printf("a = %d, b = %d\n",a , b);
				
				return 0;
			}
		作业：输入3个整数，使用条件运算符找出最大值并输出。
		
	[4] 长度运算符 
		符号及含义：sizeof()（计算括号内数据类型或表达式的大小）
		数目：无
		结合性：无
		优先级：2级
		使用方法：sizeof(表达式) 或 sizeof(类型名)
		sizeof()用于计算某类型或某表达式所占内存的大小，经常与结构体/数组等连同使用

	[5] 逗号运算符
		符号及含义：,（将多个表达式连接起来组成一个新的表达式，并将最后一个表达式的值作为整个逗号表达式的值）
		数目：未知
		结合性：自左至右
		优先级：15级（最低）
		使用方法：表达式1,表达式2,…,表达式n
		示例：y = ((x=a+b),(b+c));
		
		注意：并不是所有出现逗号的地方都组成逗号表达式，如变量说明中，函数参数表中的逗号只是用作各变量之间的间隔符。
		例如：float x = 10.5, y = 1.8, z = 0;
	
		练习：求a，b ， y及整个逗号表达式的值
			y = a = 4, b = 5 , a + b ; 		//(y = a = 4), (b = 5) , (a + b)	 == 9 ; 
											//a = 4, b = 5, y = 4
			y = (a = 4 , b = 5 , a + b); 	//a = 4, b = 5, y = 9
			y =  (a = 4 , b = 5) , a + b; 	//y = (a = 4, b = 5) , (a + b)	 == 9 ; 
											//a = 4, b = 5, y = 5
			y = a =(4, b = 5) , a + b; 		//y = a =(4, b = 5) , a + b   == 10; 	
											//a = 5, b = 5, y = 5
			
	[6] 位运算符	
		运算符					描述
		按位与( x & y )		如果两个操作数的相应位均为 1，则该位的结果值为 1
		按位或( x | y )		如果两个操作数的相应位有一个为 1，则该位的结果值为 1
		按位取反( ~x )		将操作数按位取反（0 到 1 和 1 到 0）
		按位异或( x^y )		如果参加运算的两个操作数的相应位同号，则结果为 0，异号则为 1
		左移( x<<2 )		左端（高位）移出部分舍弃，右端（低位）补0
		右移( x>>2 )		右端（低位）移出部分舍弃，左端（高位）根据符号位补0或者1，无符号或正数补0，负数补1

		注意：
		①　	位运算符中除～以外，均为二目（元）运算符，即要求两侧各有一个运算量。
		②　	运算量只能是整型或字符型的数据，不能为实型数据。
		③　	位运算符将数字视为二进制值，并按位进行相应运算，运算完成后再重新转换为数字
		
			
		(1) 按位与（&）
			&的运算规则：如果两个相应的二进制位都为１，则该位的结果值为１；否则为０
			
			按位与的使用：
				对一个存储单元清零，与进行0与运算。
				取一个数中某些指定位：如：取int a = 4321; 的低8位值，a & 0xFF
				
				0和对应二进制位相与结果为0，1和对应二进制位相与结果为本身。
				
		(2) 按位或（|）
			| 的运算规则：两个相应的二进制位中只要有一个为１，该位的结果值为１
			
			按位与的使用：
				设置一个存储单元的值。
				1和对应二进制位相与结果为1, 0和对应二进制位相与结果为本身。
				
				示例：unsigned char x= 027, y = 075,； unsigned char z = x | y; 求z的值
						x = 0b 010 111 
						y = 0b 111 101
						-----------------
							0b 111 111
				结果 z = 077
			
		(3) 按位异或（^）
			^ 的运算规则：若参加运算的两个二进制位同号则结果为０（假）异号则结果为１（真）
			
			示例：10 ^ 15 = 0101 = 5
				1010  
			 ^  1111	
			 --------
				0101
			结论：
				一个数 异或  本身恒等于0，如 0^0 = 0；1^1 = 0
				一个数 异或0 恒等于本身， 如 0^0 = 0；1^0 = 1
				一个数 每位异或1等于取反：如 0^1 = 1；1^1 = 0

			实例：通过异或运算，不用临时变量，交换两个值
			
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				int a = 3, b = 4;

				a = a ^ b; 
				b = b ^ a;	// b ^ (a ^ b) = a
				a = a ^ b;	// a ^ b ^ a = b

				printf("a = %d, b = %d\n", a, b);
				
				return 0;
			}
		
		(4) 按位取反  
			~ 的运算规则：1-->0  0-->1（若是1则变成0，若是0则变成1）
			单目运算符
			
			示例：~10
			1010 => 0101

						
		(5) 左移运算符（<<）
			左移运算符是用来将一个数的各二进制位全部左移若干位。 高位左移后溢出舍弃，右边低位补0。
			使用方法：表达式1 << 表达式2。如 a << 3 //将a变量的所有二进制位向左(高位)移动3位。
			
			若ａ＝15,  a << 2;
			0000 1111 << 2 = 0011 1100 = 60
			结论：当某个整数左移时被溢出舍弃的高位中不包含１时。左移一位相当于乘2；
			
		(6) 右移运算符（>>）
			右移运算符是将一个数的各二进制位全部右移若干位, 移到右端的低位被舍弃。
			对无符号数,高位补0。
			对于有符号数, 正数高位补0；
						  负数  逻辑右移	高位补0	
								算术右移	高位补1 	
			C语言中采用的是算术右移 
			
			使用方法：表达式1 >> 表达式2。如 a >> 3 //将a变量的所有二进制位向右(低位)移动3位。
			
			若ａ＝20,  a >> 2;
			0001 0100 >> 2 =  0000 0101 = 5 
			
			结论：当某个整数右移时被溢出舍弃的低位中不包含１时。右移一位相当于除2；
			
			1000 1111
			1110 0011
			0xe3	
			
			练习1：通过位运算符，判断正整数num是奇数还是偶数
				num & 0x1 = 1   	奇数
				num & 0x1 = 0 		偶数 
				
				#include <stdio.h>

				int main(int argc, const char *argv[])
				{
					int num;

					scanf("%d", &num);

					num & 0x1 ? (printf("%d 是奇数\n", num)) : (printf("%d 是偶数\n", num));
					
					return 0;
				}
			
			
			练习2：通过位运算符，取整型变量num的第k位（k从0开始计数）；
				(num >> k) & 0x1 
			
				#include <stdio.h>

				int main(int argc, const char *argv[])
				{
					int num;
					int k;

					scanf("%d", &num);
					scanf("%d", &k);

					printf("%x 的第%d位 为%d\n", num, k, ((num >> k) & 0x1));
					
					return 0;
				}
				
			练习3：将整型变量num的第k位（二进制表示中）置1；（k从0开始计数）；
					num | (0x1 << k)
			练习4：将整型变量num的第k位（二进制表示中）清零；（k从0开始计数）；
					num & (~(0x1 << k))
					
			作业：将无符号整型变量num的第[k+4:k]位（二进制表示中）清零.（k从0开始计数）；
			作业：将无符号整型变量num的第[k+7:k]位（二进制表示中）设为0x66.（k从0开始计数）；
			作业：取32bit无符号整数a=0x12345678 的高16bit和低16bit，分别保存在两个16bit无符号整数并显示出来

	[7] 赋值运算符及复合赋值运算
		符号及含义：=（赋值） +=（加后赋值） -=（减后赋值） *=（乘后赋值） /=（除后赋值） %=（取余后赋值）
			<<=（左移后赋值） >>=（右移后赋值） &=（按位与后赋值） ^=（按位异或后赋值） |=（按位或后赋值）
		
		数目：双目运算符（一次赋值）
		结合性：自右至左
		优先级：14级
		使用方法：
			一次赋值：待赋值 运算符 表达式。如a=3，a=5+4，a+=5 // a = a + 5;
														  a^=5 // a = a ^ 5;
			多重赋值：将同一个值赋给多个变量的操作，如a=b=c=10。此时a，b，c都为10	
			
		注意：赋值表达式的值：被赋值变量的值，就是赋值表达式的值。
		
		练习1：思考以下问题，之后编写程序观察输出结果
			int a = 2,b = 3,c = 4;
			a *= b+c;	//a = a * b + c = 10
						//a = a * (b + c) = 14
			问：a的值是多少？	//14
		
		练习题2：int a = 3; 	a += a *= a;	问：最后a的值是多少？ //18
		
			a *= a // a = a * a = 9;
			a += a // a = a + a = 18; 
			
2.C语言程序结构
	[1] C语言程序有3种基本结构：顺序结构、选择结构和循环结构。
		①谓顺序结构：就是指按照语句在程序中的先后次序一条一条的顺次执行，
			且每个语句都会被执行到。先执行A模块，再执行B模块。	
		②选择结构：选择语句又称为分支语句，它通过对给定的条件进行判断，从而决定执行两个
			或多个分支中的哪一支。 当条件P的值为真时执行A模块，否则执行B模块。
		③循环结构：是在某些条件的控制下重复执行一段代码语句，让程序“杀个回马枪”，当满足循环
			条件时执行循环语句，否则不执行循环语句。
		
	[2] 选择结构(分支)	
		(1) 条件运算符 ?:
		(2) if-else 结构
			1) 单分支结构	
				if (条件表达式) {
					语句;
					...
				}
				说明: 先计算条件表达式判断的条件，如果条件为真则执行跟在后面的是一个或一组语句，
						如果条件为假则跳过不执行。
				注意:
					如果只有一个语句，大括号{}可以省略，但不建议。
					在if后的语句不止一个，应用大括号{}将他们组织起来。
					
			2) 双重分支结构
				if (条件表达式) {
					语句-1;
					...
				} else {
					语句-1;
					...
				}
				说明: 说明: 先计算条件表达式判断的条件，如果条件为真则执行语句-1 及其后续语句，
						如果条件为假那么控制权将交给else ，执行语句-2 及其后续语句，
			
			3) 多重分支结构
				if (条件表达式-1) {
					语句-1;
					...
				} else if (条件表达式-2){
					语句-2;
					...
				} else if (条件表达式-3){
					语句-3;
					...
				} else {
					语句-4;
					...
				}
				说明：首先判断条件1是否为真，若为真，则执行语句1并跳出，若为假则继续判断条件2是否为真，
					若条件2为真则执行语句2并跳出，否则继续判断条件3。以此类推。如果所有条件都不为真，则执行else后的语句。
 
				示例: 程序输入成绩，为0~100之间的整数。之后输出成绩代表的分数段：
				90~100为优，80~89为良，70~79为中，60~69为及格，0~59为不及格，其他则输出错误信息
				
			作业: 
				输入一个年份（正整数），判断这年是否是闰年
				闰年判断标准：年份能被4整除；如若遇到100的倍数，则需判断年份能否被400整除。（逢4一闰，逢百不闰，逢400又闰）
				如1900年是不是闰年，1904年是闰年，2000年是闰年
				
		(3) switch 结构
			
		

				
			 
			
			
			
