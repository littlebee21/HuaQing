函数调用

调用全过程：
1. 调用处暂停执行后续代码
2. 执行形参定义语句
3. 将实参表达式赋值给对应形参
4. 跳转进函数体执行语句
5. 一直运行到return语句
6. 跳回到调用处（伴随着带回返回值）
7. 调用处继续执行后续代码

# 一、嵌套调用：

```
Type func1(...)
{
	....
	func2(...);
	....
}

Type func2(...)
{
	....
	func3(...);
	....
}

Type func3(...)
{
	...
	func4(...);
	....
}

func4(...)
{
	.....
}
```

嵌套调用层次受栈区大小的限制

# 二、递归调用：函数自己调用自己

和嵌套调用的比较：
1. 每次调用传参过程一样
2. 每次调用都要给形参和局部变量分配空间
   每次调用的形参和局部变量虽然名称相同，但不是同一空间，各次归各次的
3. 递归一定要有结束条件，不能无限递归
   无限递归逻辑上像死循环，但是由于栈区大小的限制会导致段错误
   
   

递归与循环：
1. 能用循环解决就不用递归
   递归依赖于函数调用,辅助空间和传参的时间都是额外消耗
   
2. 递归解决一些问题会非常简练

一般递归解决两类问题：
1. 运用调用次序

2. 用小规模解决大规模问题

倒序打印字符串

求第n个fib数列数  1 1 2 3 5 8 13 21 。。。。

猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。
第二天早上又将剩下的桃子吃掉了一半，又多吃了一个。
以后每天早上都吃了前一天剩下的一半零一个。
到第10天早上想再吃时，见只剩下一个桃子了。
求第1天共有多少桃子？
（要求：使用递归函数计算桃子的个数，
要求有函数设计,传入天数，返回桃子的个数）

