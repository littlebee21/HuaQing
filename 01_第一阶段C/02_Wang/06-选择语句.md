第七章 控制语句之选择和分支

语句：

1. 可执行语句

   1. 独立语句  --------- 都是以分号;结尾

      1. 变量定义

      2. 表达式语句

      3. 空语句;

      4. return

      5. break

      6. continue

         

   2. 复合语句

2. 非执行语句

   1. #号开头的
      1. #include
      2. #define
   2. 非#号开头
      1. 函数声明





C语言中执行语句分为两类：

1. 独立语句
2. 复合语句

本章和下一章描述复合语句，C语言中的复合语句被分为：
1. 一般复合语句，这样的复合语句由一对{}和被括起来的一条或多条其它语句组成
2. 函数定义也是一种复合语句，它在函数被调用时执行，由函数头加一个函数体
3. 控制语句：
   1) 条件语句（选择语句），由条件头和条件体组合而成
   2) 分支语句，由分支头和分支体组合而成
   3) 循环语句，由循环头、循环尾（仅do-while有）和循环体组合而成
4. 空复合语句，仅有一对{}，和仅有分号的空语句一样表示什么都不做

几点说明：
1. 上面除函数定义外，其它复合语句都只能被写在函数体里内
2. 凡是被称为什么什么头的本行均不以;结尾，
   尤其是条件头和循环头后面如果有分号，该分号被认为是空语句，编译器是不报错的，
   新手留心注意，按照我要求的编码习惯不太会容易犯这毛病的。
3. 而有尾的只是do-while循环一种，它以do为头，while(表达式)为尾，其尾以分号结尾。
4. C语言语法上对于条件体、循环体如果只有一条语句可以省略花括号对，但强烈推荐新手不要省略。

# 第一节 多重if-else

之前介绍过if-else，这里来看看一种if-else的连用模式――多重选择语句

```c
if(表达式1)
{//表达式1为真对应的条件体
    ....
}
else if(表达式2)
{//表达式2为真对应的条件体
    .....
}
else if(表达式3)
{//表达式3为真对应的条件体
    .....
}
...
else if(表达式n)
{//表达式n为真对应的条件体
    .....
}
else
{//所有表达式都为假对应的条件体，这一部分也可以不写，表示所有表达式都为假整句什么都不做
    ......
}
...
```

很显然，整个复合语句的执行方式如下：
1. 先计算表达式1，结果为真执行对应条件体直到执行完该条件体整句结束，为假继续下一步
2. 计算表达式2，结果为真执行对应条件体直到执行完该条件体整句结束，为假继续下一步
3. 计算表达式3，结果为真执行对应条件体直到执行完该条件体整句结束，为假继续下一步
4. .............
5. 计算表达式n，结果为真执行对应条件体直到执行完该条件体整句结束，为假继续下一步
6. 所有表达式都为假，则执行最后else所对应的条件体直到执行完该条件体整句结束



课堂练习：从键盘输入一个百分制分数，将其转化为等级分输出？ 
90以上，等级为A 
80-90,等级为B， 
70-80,等级为C， 
60-70，等级为D， 
60分以下，等级为E





# 第二节 嵌套if-else

所谓嵌套if-else就是条件体里嵌套了另一个由if-else领衔的选择语句。例如：
//语句1
if(表达式1)
{
    //语句2
    if(表达式2)
    {
        //语句3
        if(表达式3)
        {
            //语句4
        }
        //语句5
    }
    else
    {
        //语句6
    }
    //语句7
}
else
{
    //语句8
    if(表达式4)
    {
        //语句9
    }
    else if(表达式5)
    {
        //语句10
        if(表达式6)
        {
            //语句11
        }
        //语句12
    }
    else
    {
        //语句13
    }
    //语句14
}
//语句15

这样的代码执行逻辑是显而易见的，只有外层的条件为真，内层的条件才有被执行的可能性，例如：

1. 表达式1、2为真、表达式3为假、其它表达式无论真假时的执行路径为：语句1、2、3、5、7、15
2. 表达式1、4为假、表达式5、6为真、其它表达式无论真假时的执行路径为：语句1、8、10、11、12、14、15
3. 。。。。。。

需要注意的是，C语言语法允许如果条件体只有一条语句（独立语句或复合语句）的话，该条件体的花括号对{}可以不写，
这带来一个问题，如果嵌套别的、或者被嵌套的都是一条语句，大家的{}都没写的话，if-else如何配对呢，如：
if(表达式1)
    if(表达式2)
        //一条语句
else
    //一条语句


这个else和哪个if配对呢？
if(表达式1)
    if(表达式2)
        //一条语句
else
    //一条语句
    else
        //一条语句

第一个else和哪个if配对？第二个else又和哪个if配对？

C语言编译器按如下规则进行：**从上到下，每个else向上找最近的单身if进行配对**。
因此，上题else与表达式2的if匹配，下题第一个else与表达式2的if匹配，第二个else与表达式1的if匹配。(对齐形式成了烟雾弹了)

但是，项目开发中，我们不推荐大家省略{}，哪怕条件体没有语句，{}不省略，一来没有了匹配问题，二来代码清晰易读！





函数在项目中的三个常见作用：

1. 功能性函数
2. 拼装性函数
3. 简化性函数



# 第三节 分支语句switch

这是针对整型比较相等的多重if-else的改进，这种形式的语句，看上去比多重if-else更清爽，执行效率也相对更好。其语法形式如下：

```c
switch(整型表达式)
{//分支体
    case 整型常量1:
          //case体1;
        break;
    case 整型常量2:
        //case体2;
        break;
    case 整型常量3:
        //case体3;
        break;
    ..............
    case 整型常量n:
        //case体n;
        break;
    default:
        //default体
        break;        
}
//后续语句
```

整个语句的执行规则如下：
1. 计算整型表达式的值
2. 该值如果等于整型常量1，则执行case体1，然后执行break语句跳出整个switch语句执行后续语句，如果不等继续下一步
3. 该值如果等于整型常量2，则执行case体2，然后执行break语句跳出整个switch语句执行后续语句，如果不等继续下一步
4. 该值如果等于整型常量3，则执行case体3，然后执行break语句跳出整个switch语句执行后续语句，如果不等继续下一步
5. 。。。。。。。。
6. 该值如果等于整型常量n，则执行case体n，然后执行break语句跳出整个switch语句执行后续语句，如果不等继续下一步
7. 如果整型表达式的值与以上整型常量均不相等，则执行default体，直到结束或遇到break跳出整个switch语句执行后续语句。

注意switch语句使用的两个硬前提：
1. switch后的括号里只能是整型表达式或可以相当于整型的类型如字符型，不可以是浮点型等其它不能等价于整型的类型
2. case后只能是整型常量，注意两个关键词先是整型然后常量，当然字符常量也是可以的（字符常量的本质是其对应的ASCII值）

这里，涉及到一种语句叫break，这个语句就是break加分号：break;    这个语句将立即结束执行其所隶属的switch或循环语句。

有趣的是switch中每种情况条件体后的break语句不是必须的，如果一个case体最后没有break，整型表达式的值又恰好等于这种case，
那么执行完该case体后怎么执行呢？C语言将采用“导通法”：直接执行下一个case体或default体直到switch语句结束或遇到break语句。

项目中，你如果一个case体后由于程序需要不用写break语句，那么你应该将原break语句所在行改成一句注释，如下所示：
switch(整型表达式)
{
    case 整型常量1:
        //case体1;
        break;
    case 整型常量2:
        //case体2;
        //go though 此注释表明，break语句你不是忘记写了，而是就要刻意用这种执行次序。方便维护者阅读你的代码
    case 整型常量3:
        //case体3;
        break;
    ..............
    case 整型常量n:
        //case体n;
        //go though
    default:
        //default体
        break;        
}
//后续语句

一个利用不写break的小技巧，如果有多个case条件体的代码一模一样的话，你不用每个条件体重复书写，可以像如下形式书写：
switch(整型表达式)
{
    case 整型常量1:
    case 整型常量2:
    case 整型常量3:
        //case体1;
        break;
    ..............
    case 整型常量n:
        //case体n;
        break;
    default:
        //default体
        break;        
}

这样写法意味着整型表达式的值等于整型常量1或者整型常量2或者整型常量3都是执行case体1。

最后，与之间的条件体不一样，各case体、default体可以不加花括号{}的，因为在结构上已经将不同的case区分开来了。
当然，你加了也不会有啥副作用。

课堂练习1： 简易计算器，输入两个数字和一个运算符号（加减乘除），执行做对应计算并输出计算结果 （要求源文件名calc.c）







## 第四节 产生随机数的C库函数
所谓随机数就是后面的那个数与前面的那个数毫无关系，通俗地讲就是新的随机数的出现具有不确定性的。
真正的随机数是使用物理现象产生的：比如掷钱币、骰子、转轮、使用的电子元件噪音、核裂变等等。绝大多数软件开发中使用伪随机数就足够了，C库中有个函数每被调用一次可以产生一个伪随机数（后面我们也称为随机数）――rand：

函数声明包含头文件：#include <stdlib.h>
函数原型：int rand();
函数功能：该函数每被调用一次产生一个在0到RAND_MAX范围内随机数

例如：
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int x = -1;
    int y = -1;
    int z = -1;

    x = rand();
    y = rand();
    z = rand();
    
    printf("x=%d,y=%d,z=%d\n",x,y,z);    
    return 0;
}

程序运行结果：
x=1804289383,y=846930886,z=1681692777

再次运行n遍，每次输出都是：
x=1804289383,y=846930886,z=1681692777

这明显失去了随机的真义了，C库中的rand函数产生随机数过程如下：
       调rand函数程序都有一个初始值被称为种子数，第一随机数的产生是种子数代入一个公式（公式长得什么样我们无须关心）经过计算所得，
       然后种子数变为第一个随机数，第二个随机数的产生则是将新种子数（即第一个随机数）代入同一个公式计算所得，。。。。。。
       我们每次启动程序时原始种子数都是一样的，因此造成了这样的现象。

怎么解决呢？C库中提供另一个函数srand用来改变种子数，我们来看看这个函数：
函数原型：void srand(unsigned int seed);
函数声明：#include <stdlib.h>
函数功能：改变程序中的随机数种子数为调用者指定的数值

接着，怎样指定这个数值呢？我们要这个数值在程序每次运行时都不一样，同一个程序不同次运行的运行的时刻是不一样，如果我们能得到程序执行到某处的时刻就可以达到我们的要求了，C库提供这样的一个函数：
函数原型：time_t time(time_t* tp);
函数声明：#include <time.h>
函数功能：得到从标准计时点（一般是1970年1月1日午夜）到当前时间的秒数。
形式参数：tp是一个指针类型，我们后面才能学到，不过这个函数调用时实参运行写成NULL，这些我们当下都不用管，我们可以这样调用这个函数time\(NULL\)
返回值：其类型是time_t，这个你可以认为unsigned int。
与srand配合调用可以写成：
    srand(time(NULL));  
本句先调用time函数得到当前秒数，然后再调用srand改变随机数种子，修改后的程序如下：
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main()
{
    int x = -1;
    int y = -1;
    int z = -1;

    srand(time(NULL));
    x = rand();
    y = rand();
    z = rand();
    
    printf("x=%d,y=%d,z=%d\n",x,y,z);    
    return 0;
}

程序执行结果如下：（你的结果会和我的不一样，因为运行时刻大家不一样）
x=783959951,y=2027585668,z=1992837975

最后一个问题，这些随机数太大了咋办？你经常想得到指定范围内的随机数比如：3~29，
动动你的小脑筋运用一下取余运算%，我们可以这样哦：rand() % 27 + 3  （任何数取余27得到0~26间的数，加上3得到3~29间的数）



课堂练习：石头剪刀布    Rock-Scissors-Paper
