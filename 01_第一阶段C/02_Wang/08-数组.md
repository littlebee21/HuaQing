# 第一节 数组的概念和分类

1.1 数组的概念

在实际项目中我们往往不可避免地需要处理大量同类型的数据，比如：每月开支、日降水量、员工资料、库存清单、交易记录等等，而数组这种数据类型就是存储、操作同类型数据的一种手段。

所谓数组，表面意思就是很多个“数”连成一“组”，显然与之前基本类型的变量不一样，这不是研究单个“数”的存储和操作，这是用来研究多个相同类型“数”的手段。这样的单个“数”在后续被称为一个――元素。一个数组中最多容纳的元素个数被称为――数组的长度或数组的大小或数组的容量。

在C语言中，数组(Array)的定义是：数组是一种数据类型，这种类型的变量空间中可以**连续顺序**地存放多个**相同类型**的元素。

在学科数据结构中数组也被称为顺序表，顺序两字充分体现了一个数组是按照这样的方式存储多个同类型元素的：一个紧挨着一个顺序地在其空间中存放元素。

本章之前我们提及到的变量均为基本类型的变量，这样的变量你应该把它看成一个只能存放一个物品的器皿，而用数据类型来描述存放其中的物品类型。
数组也是一种数据类型，这种类型的变量空间中可以顺序存放多个相同数据类型元素，可以将其看作存放小器皿的更大器皿，这种类型的变量也被泛称为数组，  
因此变量这个词在C语言有广义和狭义的之分：
1. 广义上变量统指所有类型的变量，这个意义上我们认为数组类型的变量也是一个变量
2. 而习惯上（即狭义上），我们一般只称基本类型的变量叫变量，而称：

   		1). 数组类型的变量简称为数组
        		2). 指针类型的变量简称为指针（见后续章节）
        		3). 结构体类型的变量称为结构体变量（见后续章节）
        		4). 共用体类型的变量称为共用体变量（见后续章节）

1.2 数组的分类

一、数组按其内存空间的来源方式可以分为：

1. 静态数组：在编译时必须知道其长度，即需用常量表达式指定数组长度，其空间只能通过数组定义语句分配。
2. 动态数组：在运行时动态地分配数组。虽然数组长度也是固定的，但动态分配的数组不必在编译时知道其长度，通常在运行时才确定数组长度。

其实这样的区分不仅针对数组，所有类型的元素所需的空间来源，都有两种：
1. 通过变量定义语句 
2. 动态分配。（见后续章节）

本章主要研究静态数组，后续课程中除非特殊情况下特殊说明，提到数组往往都特指静态数组。

二、数组按摆放元素的方案可以分为：

1. 一维数组
2. 二维数组
3. ......
4. N维数组

N维数组中的N被称为数组的维度。现实生活中，我们顺序地摆放相同形状的物品也是有多种摆放形式的，比如：

1. 将物品简单地排成一条线 （即一维数组）
2. 先将少数物品排成一行，然后再起下一行摆放相同数目的物品，即所谓的行列式摆放物品（即二维数组）
3. 以限定的行列为一层，然后再起下一层，每一层都按相同的行列摆放物品（即三维数组）
4. .....（即N维数组）

大家记住，不管是多少维，所有元素在这个数组的内存空间里存放都是顺序式的，只是我们对这个空间的认识模式不一样而已，详细见后续各维数组的描述。

一种有趣的理解方法，大家可以将整个数组的空间看成是一个大饼，数组的维度就是在告诉我们要经过多少轮的挥刀可以均匀地等分大饼：
1. 第一维大小，就是让我们第一轮挥刀先将大饼等分为多少份。
2. 第二维大小，就是让我们第二轮挥刀将第一轮每等分再等分为多少份。
3. 。。。
4. 第N维大小，就是让我们第N轮挥刀将前一轮每等分再等分为多少份。

# 第二节 一维数组

### 2.1 定义初始化和sizeof

一维数组的定义语法：

```c
//Type为除void类型外的其它所有C语言支持的数据类型
//Type是元素的数据类型
//N是数组中元素的个数，N只能结果为正整型的常量表达式
Type 数组名[N];

例如：int arr[5];

Type 数组名[N] = {表达式0,表达式1,表达式2,.....,表达式N-1};

Type 数组名[N] = {表达式0,表达式1,....表达式m};//m < N 未被初始化的元素系统自动初始化为对应0值

Type 数组名[] = {表达式0,表达式1,....表达式N-1};
```

N表示该数组中可以存放的元素个数的最大值（即数组长度或数组大小），只能是正整型的常量或常量表达式。
语法通式中所有表达式均为Type类型表达式。

sizeof(数组名) = N * sizeof(Type)

下标：数组中每个元素按顺序摆放的编号，最小取 0，最大到 N-1，为负或&gt;=N 引发的错误称为越界

下标运算符： 数组名[]，其用法为：数组名[下标表达式]

下标运算符的作用：通过数组名和计算所得的下标值访问对应位置编号的一个元素，即为一个元素所在空间的名字

### 2.2 定义语句的理解

一维数组定义语句的作用：
1. 分配 N*sizeof(Type)个字节的空间
2. 给整个空间命名为数组名
3. 从该内存空间首地址开始每 sizeof(Type)个字节存放一个Type类型的元素
4. 定义了 N 个 Type 类型的变量，它们分别叫：数组名[下标表达式]

很显然，前三个作用描述类似于基本类型的变量定义，由于是数组因此有第四个作用。

### 2.3 相关运算

一、对整个一维数组的运算

1. 不可以的操作：对数组名直接赋值，记住与其它类型的变量名不一样所有数组名不可以直接出现在赋值号的左边。
2. sizeof(数组名)：N*sizeof(Type)
3. 取地址运算&：可以进行，但是注意所得地址类型不是元素类型的地址，而是数组类型的地址（见后续章节）

二、对元素的运算
1. 访问元素：数组名[下标表达式]
2. 名称叫一维数组名[下标表达式]的元素的运算 与 同类型的变量支持的运算完全一致
3. 遍历方法：用一层循环控制下标变化顺序地挨个访问或使用元素所在空间。
典型的做法：

for(i = 0;i < N;i++) //N为数组大小，i表示下标
{
    //arr[i]相关的操作
}



### 常见操作：

1. 输入输出

2. 在无序数组中查找元素

     1. 顺序查找
     2. 哨兵法

3. 找最大、最小

     

4. 插入元素：已知有数组double arr[5+1] = {1.1,3.3,5.5,7.7,9.9},让用户输入一个浮点数，并将其插入到下标为3的位置，然后输出数组

     

5. 删除元素：已知有数组double arr[5] = {1.1,3.3,5.5,7.7,9.9}，请删除下标为2的元素后输出数组

     

6. 在有序数组中查找元素

     1. 顺序查找
     2. 折半查找（二分查找）
     3. 插值查找 mid = low + （key-arr[low]）* (high - low) / (arr[high] - arr[low])

7. 排序
      1） 冒泡排序
      2） 选择排序
      3） 插入排序

  

# 第三节 二维数组

## 3.1 定义初始化和sizeof

二维数组的定义语法：

```c
//Type为除void类型外的其它所有C语言支持的数据类型
Type 数组名[M][N];

Type 数组名[M][N]= {{表达式0~0,表达式0~1,.....,表达式0~Y1},
                     {表达式1~0,表达式1~1,.....,表达式1~Y2},
                     ...,
                     {表达式X~0,表达式X~1,.....,表达式X~Y3}};// X < M; Y1 Y2 Y3 < N

Type 数组名[][N] = {{表达式 0~0,表达式 0~1,.....,表达式 0~X1},
                     {表达式 1~0,表达式 1~1,.....,表达式 1~X2},
                     ...,
                     {表达式 M-1~0,表达式 M-1~1,.....,表达式 M-1~Xn}};//该数组一共M行，X1 X2 Xn < N


M*N 表示该数组中可以存放的元素个数的最大值,分为M行，每行可以存放N个元素。
    
sizeof(二维数组名) = M*N*sizeof(Type)
    
下标：数组中每个元素按行列摆放的编号：
1. 第一维下标（行下标）：最小取 0，最大到 M-1，为负或>=M 引发的错误称为行越界
2. 第二维下标（列下标）：最小取 0，最大到 N-1，为负或>=N 引发的错误称为列越界


下标运算符：
1. 二维数组名[]，其用法为：二维数组名[下标表达式]，其结果为：一个一维数组的名字
2. 二维数组名[][]，其用法为：二维数组名[行下标表达式][列下标表达式]，其结果为：一个元素所在空间的名字


```

## 3.2 定义语句的理解

二维数组定义语句的作用：

1. 分配 M*N*sizeof(Type)个字节的空间
2. 给整个内存空间命名为二维数组名
3. 从该内存空间首地址开始每 sizeof(Type)个字节存放一个 Type 类型的元素
4. 定义了M个一维数组，它们分别叫：二维数组名[第一维下标表达式]
5. 定义了 M*N 个 Type 类型的变量，它们分别叫：`二维数组名[第一维下标表达式][第二维下标表达式]`

## 3.3 相关运算

一、对整个二维数组的运算

1. 不可以的操作：对二维数组名直接赋值，对 二维数组名[行下标表达式] 进行直接赋值 均不成立，即这两种写法不可以出现在赋值号的左边
2. sizeof(二维数组名)：M* N* sizeof(Type)
   sizeof(二维数组名[第一维下标表达式])：N* sizeof(Type)
3. 取地址&：可以进行，但是注意所得地址类型不是元素类型的地址，而是数组类型的地址（见后续章节）

二、对元素的运算和其它运算
1. 访问元素：`二维数组名[行下标]`访问某一行（一个一维数组名），`二维数组名[行下标表达式][列下标表达式]`访问某一元素（元素的名字）
2. 名称叫 `二维数组名[行下标表达式]`的一维数组的运算 与同类型的一维数组支持的运算完全一致
3. 名称叫 `二维数组名[行下标表达式][列下标表达式]`的元素的运算 与同类型的变量支持的运算 完全一致
4. 遍历方法：用两层嵌套循环分别控制行下标和列下标的变化顺序地挨个访问或使用元素所在空间。典型的做法：

```c
for(i = 0;i < M;i++) //M为总行数，i表示行下标
{
    for(j = 0;j < N;j++) //N为列数，j表示列下标
    {
        //arr[i][j]相关的操作
    }
}
```



# 第四节 多维数组

## 4.1 三维数组

一、三维数组的定义初始化和sizeof

定义语法：

```
Type 数组名[M][N][Q];
Type 数组名[M][N][Q] = 三层{}嵌套形式;
Type 数组名[][N][Q] = 三层{}嵌套形式;


M*N*Q 表示该数组中可以存放的元素个数的最大值,分为 M 层,每层可以存放 N 行,每行可以存放 Q 个元素

sizeof(数组名) = M*N*Q* sizeof(Type)

下标：数组中每个元素按层行列摆放的编号：
1. 第一维下标（层下标）：最小取 0，最大到 M-1，为负或>=M 引发的错误称为层越界
2. 第二维下标（行下标）：最小取 0，最大到 N-1，为负或>=N 引发的错误称为行越界
3. 第三维下标（列下标）：最小取 0，最大到 Q-1，为负或>=Q 引发的错误称为列越界

下标运算符：
1. 三维数组名[]，其用法为：数组名[层下标表达式]，其结果为：一个二维数组的名字
2. 三维数组名[][]，其用法为：数组名[层下标表达式][行下标表达式]，其结果为：一个一维数组的名字
3. 三维数组名[][][]，其用法为：数组名[层下标表达式][行下标表达式][列下标表达式]，其结果为：一个Type类型元素的名字


```

二、三维数组定义语句的作用：

```
二维数组定义语句的作用：

1. 分配 M*N*Q*sizeof(Type)个字节的空间
2. 给整个空间命名为三维数组名
3. 从该内存空间首地址开始每 sizeof(Type)个字节存放一个 Type 类型的元素
4. 定义了 M 个二维数组，它们分别叫：三维数组名[层下标表达式]
5. 定义了 M*N 个一维数组，它们分别叫：三维数组名[层下标表达式][行下标表达式]
6. 定义了 M*N*Q 个 Type 类型的变量，它们分别叫：
   三维数组名[层下标表达式][行下标表达式][列下标表达式]
```

三、相关运算

对整个三维数组的运算：

1. 不可以的操作：对三维数组名、`三维数组名[层下标表达式]`、`三维数组名[层下标表达式][行下标表达式]`均不可以直接赋值
2. sizeof：`M*N*Q*sizeof(Type)`
3. 取地址&：可以进行，但是注意所得地址类型不是元素类型的地址，而是数组类型的地址（见后续章节）

对元素的运算和其它运算：

1. 访问元素：`三维数组名[层下标]`访问某一层（一个二维数组名），
            `三维数组名[层下标表达式][行下标表达式]`访问某一行（一个一维数组名），
            `三维数组名[层下标表达式][行下标表达式][列下标表达式]`访问某一元素（一个Type类型变量名）

2. 名称叫`三维数组名[层下标表达式]`的二维数组的运算与同类型的二维数组所支持的运算完全一致

3. 名称叫`三维数组名[层下标表达式][行下标表达式]`的一维数组的运算与同类型的一维数组所支持的运算完全一致

4. 名称叫`三维数组名[层下标表达式][行下标表达式][列下标表达式]`的元素的运算与同类型的变量所支持的运算完全一致

5. 遍历方法：用三层嵌套循环分别控制层下标、行下标和列下标的变化顺序地挨个访问或使用元素所在空间。典型的做法：
   
   ```c
   for(i = 0;i < M;i++) //M为总层数，i表示层下标
   {
   	for(j = 0;j < N;j++) //N为每层行数，j表示行下标
       {
       	for(k = 0;k < Q;k++) //Q为每层每行的列数，k表示列下标
           {
           	//arr[i][j][k]相关的操作
           }
       }
   }
   ```
   
   

## 4.2 N维数组

N维数组的理解，用一句流行语来说就是：”套路，全是套路！“

一、n维数组的定义初始化和sizeof

1. ```
   定义语法：
   Type 数组名[M1][M2]....[Mn];
   Type 数组名[M1][M2]....[Mn] = N层{}嵌套形式;
   Type 数组名[][M2]....[Mn] = N层{}嵌套形式;
   
   M1*M2*...*Mn 表示该数组中可以存放的元素个数的最大值。
   
   sizeof(数组名) = M1*M2*...*Mn*sizeof(Type)
   
   下标：数组中每个元素按层行列摆放的编号：
   
   1. 第一维下标：最小取 0，最大到 M1-1，为负或>=M1 引发的错误称为第一维越界
   2. 第二维下标：最小取 0，最大到 M2-1，为负或>=M2 引发的错误称为第二维越界
   3. .....
   4. 第n维下标：最小取 0，最大到 Mn-1，为负或>=Mn 引发的错误称为第n维越界
   
   下标运算符：
   
   1. n维数组名[]，其用法为：数组名[第一维下标表达式]，其结果为：一个N-1维数组的名字
   2. n维数组名[][]，其用法为：数组名[第一维下标表达式][第二维下标表达式]，其结果为：一个N-2维数组的名字
   3. ....
   4. n维数组名[][].....[]（共计n-1对[]）,其用法为：数组名[第一维下标表达式][第二维下标表达式]...[第n-1维下标表达式]，其结果为：一个一维数组名
   5. n维数组名[][].....[]（共计n对[]），其用法为：数组名[第一维下标表达式][第二维下标表达式]...[第n维下标表达式]，其结果为：一个Type类型元素的名字
   ```

   

二、n维数组定义语句的作用：

```
n维数组定义语句的作用：（共计n+3个作用）

1. 分配 M1*M2*...*Mn*sizeof(Type)
2. 给整个空间命名为n维数组名
3. 从该内存空间首地址开始每 sizeof(Type)个字节存放一个 Type 类型的元素
4. 定义了 M1 个n-1维数组，它们分别叫：n维数组名[第一维下标表达式]
5. 定义了 M1*M2 个n-2维数组，它们分别叫：n维数组名[第一维下标表达式][第二维下标表达式]
6. 。。。。。。
7. 定义了 M1*M2*....*M(n-1)个 一维数组，它们分别叫：n维数组名[第一维下标表达式][第二维下标表达式]...[第n-1维下标表达式]
8. 定义了 M1*M2*....*Mn个Type类型变量，它们分别叫：n维数组名[第一维下标表达式][第二维下标表达式]...[第n维下标表达式]
```

三、相关运算

```
对整个n维数组的运算：

1. 不可以的操作：
   对n维数组名、
   n维数组名[第一维下标表达式]、
   n维数组名[第一维下标表达式][第二维下标表达式]、
   ....... .............
   n维数组名[第一维下标表达式][第二维下标表达式]...[第n-1维下标表达式]均不可以直接赋值
2. sizeof：M1*M2*...*Mn* sizeof(Type)
3. 取地址&：可以进行，但是注意所得地址类型不是元素类型的地址，而是数组类型的地址（见数组指针15.6节）

对元素的运算和其它运算：

1. 访问元素：n维数组名[第一维下标]访问一个n-1维数组（一个n-1维数组名），
       n维数组名[第一维下标][第二维下标]访问一个n-2维数组（一个n-2维数组名），
       ...，
       n维数组名[第一维下标][第二维下标]...[第n-1维下标]访问一个一维数组（一个一维数组名），
      n维数组名[第一维下标][第二维下标]...[第n维下标]访问一个元素（一个Type类型变量名）
2. 名称叫n维数组名[第一维下标]的n-1维数组的运算与同类型的n-1维数组所支持的运算完全一致
3. 名称叫n维数组名[第一维下标][第二维下标]的n-2维数组的运算与同类型的n-2维数组所支持的运算完全一致
4. 。。。。。。
5. 名称叫n维数组名[第一维下标][第二维下标]...[第n-1维下标]的一维数组的运算与同类型的一维数组所支持的运算完全一致
6. 名称叫n维数组名[第一维下标][第二维下标]...[第n维下标]的元素的运算与Type类型的变量所支持的运算完全一致
7. 遍历方法：用n层嵌套循环分别控制层下标、行下标和列下标的变化顺序地挨个访问或使用元素所在空间。典型的做法：

for(i1 = 0;i1 < M1;i1++) //M1为第一维大小，i1表示第一维下标
{
    for(i2 = 0;i2 < M2;i2++) //M2为第一维大小，i2表示第一维下标
    {
        。
            。
                。
                    for(in = 0;in < Mn;in++) //Mn为第n维大小，in表示第n维下标
                    {
                        //arr[i1][i2]...[in]相关的操作
                    }
                。
            。
        。
    }
}
```



# 第五节 数组作为函数形参类型

## 5.1 一维数组作为函数形参类型

函数形参类型为一维数组，特点：

1. 数组大小不用写，写了也没有任何作用
2. 实际传的是数组所在空间的地址值，意味着：
   a. 可以修改被传数组内容
   b. 函数中并不能直接知道数组中元素的数目，
      1)因此需要一个整型参数配合，通过该参数告诉函数数组的大小
      2)数组有特殊的结束标记，结束标记之前的是有效元素，
      　此时仅需要一个一维数组的形参即可
      3)传首地址，配合以开始下标和结束下标
      4)传首地址，配合以最后一个元素的地址
3. 调用时实参直接写被处理数组的数组名

```
通式1：适用于没有结束标记的一维数组
函数定义：
T	函数名(Type 参数名[],int count,...) //...表示可能有其它参数
{//遍历count控制下标不越界，注意下标范围[0,count-1]

}

函数调用：
//先定义一个元素为Type型的一维数组
Type arrname[M] = {...};

//调用函数
函数名(arrname,M,...) //...表示与其它形参对应的实参
```

```
通式2：适用于没有结束标记的一维数组
函数定义：
T	函数名(Type 参数名[],int low,int high ...) //...表示可能有其它参数
{//遍历下标low到下标high元素

}

函数调用：
//先定义一个元素为Type型的一维数组
Type arrname[M] = {...};

//调用函数
函数名(arrname,0,M-1,...) //...表示与其它形参对应的实参
```

```
通式3：适用于一维数组有个特殊元素作为结束标记的情况
函数定义：
T	函数名(Type 参数名[],...) //...表示可能有其它参数
{//遍历利用元素是否与结束标记相等作为结束条件

}

函数调用：
//先定义一个元素为Type型的一维数组，并且始终保证该数组中有结束标记存在
Type arrname[M] = {...};

//调用函数
函数名(arrname,...) //...表示与其它形参对应的实参
```



## 5.2 二维数组作为函数形参类型

二维数组类型可以作为函数形参类型，其特点：
1. 第一维大小不用写，写了也没有任何作用
	第二维大小必须写，和定义语句一样，只能是正整型常量
2. 实际传的是二维数组所在空间的地址值，意味着：
   a. 可以修改被传数组内容
   b. 函数中并不能直接知道二维数组中行数，
      因此需要一个整型参数配合，通过该参数告诉函数行数
3. 调用时实参直接写被处理二维数组的数组名，并且：
	a. 元素类型一致
	b. 列数相同（即每行元素个数一致）
	

通用形式：

```
函数定义：
T 函数名(Type 参数名[][N],int row,...)  //...表示可能有其它参数
{//row为本次处理的二维数组的行数

}
```

函数调用：

```
//先定义一个元素类型为Type,每行有N个元素的二维数组
`Type arrname[M][N]` = {{...}};

//调用函数
函数名(arrname,M,...) //...表示与其它形参对应的实参
```

5.5.3 N维数组作为函数形参类型

类似于二维数组，第一维大小不写，后续所有维大小必写

通用形式：

```
函数定义：
T 函数名(Type 参数名[][M2][M3]...[Mn],int count,...)  //...表示可能有其它参数
{//count为本次处理的N维数组中(N-1)维数组的个数

}
```

函数调用：

```
//先定义一个元素类型为Type,除第一维大小外，其它维大小与函数形参完全一致的N维数组
`Type arrname[M1][M2][M3]...[Mn]` = {{{...{...}}}};

//调用函数
函数名(arrname,M1,...) //...表示与其它形参对应的实参
```



# 第六节 数组作为函数返回值类型

所有数组类型均不能作为函数返回值类型



# 第七节 数组口诀

C语言语法理论上可以支持随便多少维的数组,实际项目中遵循不成文的“事不过三”原则。但是不管多少维，你只要记住数组口诀配以画内存图都能搞定：

总决：**N维数组都可以看作是一维数组，这个一维数组中的元素都是N-1维的数组**
分决：

1. **数组名在表达式中单独出现时，其等价于：下标为0元素所在空间首地址**，两种情况除外：
   a. &数组名  此时数组名代表整个数组所占内存空间
   b. sizeof(数组名) 此时数组名代表整个数组所占内存空间
2. **数组类型作为函数形参类型，该形参完全等价于：指向数组元素的指针**，即用来存放地址值的变量（可以存放数组中某一个元素内存空间的首地址）













函数返回值类型为int的运用方式：

1. 判断某个东东是不是什么玩意儿 ，此时返回值当逻辑值用，返回1表示是某玩意儿，返回0表示不是
2. 表示本次函数调用是不是正常完成了函数的功能，此时返回0表示正常完成功能，返回其它值表示发生了错误，没能正常完成功能
3. 返回的整型数具有现实意义的一个数字