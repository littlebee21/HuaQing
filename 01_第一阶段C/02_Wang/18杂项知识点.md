# 一、if-else配对问题

条件语句、循环语句如果条件体、循环体中仅有一条语句是{}可省略的

```c
if(表达式1)
    if(表达式2)
    	一条语句
else
    一条语句
else
    一条语句

//配对规则：向前找最近的没有成家的if
避免方式：任何情况不省略{}
```



# 二、一行定义多个指针问题

如果多个变量的数据类型一样，C语言允许一行定义多个变量

```c
//T为非指针类型时
T t1,t2,t3; //不建议
T t1 = ... ,t2 = .... ,t3 = ....; //不建议
//建议做法
T t1 = ....;//t1的注释
T t2 = ....;//t2的注释
T t3 = ....;//t3的注释


//指针类型时
T *p1,p2,p3;//p1是指针，p2,p3是T类型的变量 不建议
T *p1 = ...,*p2 = ....,*p3 = ....;//p1,p2,p3都是指针 不建议
//建议做法
T* p1 = ....;//p1的注释
T *p2 = ....;//p2的注释 ---  编译器采用的读法
T * p3 = ....;//p3的注释

/*因此，项目开发过程中，我们一行仅定义一个变量，并对该变量做符合逻辑的初始化，如临时无法确定初始化的值，则初始化成相应的零值*/
```

# 三、类型设计语句的特殊用法

```c
/*结构体、共用体、枚举、typedef一般都是写在.c文件第一个函数定义之前 或者 写在一个头文件里被.c文件包含*/

//无名的结构体类型 --- 类型设计和所有该类型变量、指针变量、数组定义必须写在一起
//后续代码中无法再定义此种类型的变量、指针、数组
struct 
{
  	int a;
    float b;
} t1,t2,*pt,arr[5];
//这样的语句如果写在.c文件第一个函数定义之前，则t1,t2,pt,arr均会成为全局变量，因此不推荐这种写法
//这样的语句如果写在某个函数体内，其它函数内无法再用该结构体类型

/*推荐做法：
1. 类型设计语句单独写成非执行语句
2. 如果写在.c文件第一个函数定义之前，意味着只能在当前.c内使用该数据类型
3. 如果多个.c文件都需使用该数据类型，则应将类型设计语句写到某个头文件里，让需要使用该数据类型的.c文件包含
*/

```

# 四、重名问题

```c
//一、变量重名
//1. 全局变量和局部变量、函数形参重名 ---- OK
//2. 函数体局部变量和函数形参重名 ---- No OK
//3. 同一函数体内，不同复合语句局部变量重名 -----OK
//4. 不同函数体的形参、局部变量重名 ---- OK
//允许重名原则：名称使用范围的结尾不一样则允许重名

//项目开发过程中：除了不同函数的形参、局部变量可以重名外，其它重名都应避免

//重名时，语句中出现的名字如何设别是哪个？
//设别原则：优先选用同一复合语句内定义局部变量，如果同一复合语句内无此变量定义，则看其上一层复合语句里有没有定义语句，如此从内到外，最后才选用全局变量
int x = 3;//A处
int func1()
{
    int x = 6;//B处
    {
        int x = 9//C处
    
    	{
#if 1
            int x = 21;//D处
        	y = x + 2;//x 同一复合语句内定义的x----D处  
#else
            y = x + 2;//x ----C处  
#endif
    	}
        
        k = x -3//x? C处
    }
    
    z = x * 3;//x? B处
    
}
int func2()
{
    h = x -2;//x? A处
}

```

```c
//函数重名
//不同.c文件中的static函数允许重名
//不同.c文件中的非static函数不允许重名
//同一.c文件中的static函数不允许重名
//同一.c文件中的非static和static函数不允许重名

//项目开发过程，所有函数都应避免重名
```

# 五、结构体的sizeof问题

结构体的sizeof是大于等于所有成员的sizeof之和

编译器为了加快对结构体变量成员访问速度，往往会在结构体变量的空间中填充一些额外字节

![1641534511972](Note杂项知识点.assets/1641534511972.png)

```c
struct T
{
    int i;
    char c1;
    double d;
    char c2;
};

64位平台：
    sizeof(T) = 24
32位平台：
    sizeof(T) = 20
    
算法：
1. 确定基准对齐值：结构体对齐值和平台对齐值的最小值
    1> 结构体对齐值
    	结构体成员中sizeof最大成员的sizeof ------- 基本类型和指针
    2> 平台对齐值
 		32位平台是4
        64位平台是8
2. 结构体的sizeof值要求一定是基准对齐值的整数倍
3. 确保每个基本类型、指针类型成员的访问速度最快
    1> 如果成员sizeof大于基准对齐值，则确保该成员空间的首地址为基准对齐值的整数倍，否则就填充字节达到整数倍效果
    2> 如果成员sizeof小于等于基准对齐值，则确保该成员空间的首地址为其自身sizeof的整数倍，否则就填充字节达到整数倍效果
    
    
    
项目开发过程中，为了达到字节对齐的目的，又能尽量少的补充字节数，对结构体中成员排列次序要求：
    1. 先将sizeof是基准对齐值整数倍的成员，按sizeof的大小从大到小排列
    2. 再将sizeof不是基准对齐值整数倍的成员，按sizeof的大小从大到小排列
    3. 最后程序员自己添加一个char型数组成员，来确保“结构体的sizeof值要求一定是基准对齐值的整数倍”
    4. 前提是“结构体成员排列次序与程序逻辑无关”
struct T
{
    double d;
    int i;
    char c1;    
    char c2;
    char rev[2];
};

64位平台：
    sizeof(T) = 16

32位平台：
    sizeof(T) = 16
    
```

# 六、字段（位域）

可以将结构体中**整型成员**按位指定名称和作用

```
struct 结构体
{
	unsigned int a : 4;
	unsigned int b : 8;
	unsigned int c : 12;
	unsigned int d : 8;//最大是8

	unsigned int e : 2;//第二个unsigned int成员
	
	float f;

};
```

```
struct 结构体
{
	unsigned int a : 4;
	unsigned int  : 8;//跳过8位，或者说这8位保留不用
	unsigned int c : 12;
	unsigned int d : 8;

	float f;

};
```

```
struct 结构体
{
	unsigned int a : 4;
	unsigned int b : 8;
	unsigned int c : 0;//当前unsigned int后续位全部给c用
		

	unsigned int d : 8;//下一个unsigned int成员
	
	float f;

};
```

```
struct Person
{
	char name[20];
	

	unsigned short sex : 2;
	unsigned short age : 0;

};
```

```
struct Person
{
	char name[20];

	unsigned short sexandage;
};
```



# 