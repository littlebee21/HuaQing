指针指向的元素类型可以是任何数据类型，甚至包含void，只不过此时含义是指向空间的二进制位含义不确定。
万变不离其宗，只要是指针，其自身空间就是存放着一个地址值，只是指向空间元素的类型可以千变万化。
不过有些非常特殊指针，大家要注意：

1. 多级指针（指向指针的指针）
2. 数组指针:将一种数组整体看成是一种元素，数组指针指向的就是这种怪形式的元素
3. 函数指针：指向一个函数

# 一、多级指针

理论上支持任意级指针，实际运用中“事不过三”，因此重点掌握到一级指针、二级指针、三级指针

## 1.1 二级指针

所谓的二级指针就是指向指针的指针：
Type ** ppname;
Type ** ppname = 地址表达式;

定义语句意味着：  
1. ppname指向空间里可以存放一个或多个Type *类型的元素，这些元素是一级指针，  
2. 而这些一级指针再次指向的空间里可以存放一个或多个Type类型的元素  
3. 二级指针自己也是指针，也是变量，也一样有自身的内存空间，其空间中存放的也是地址值，只是以这个地址值为首地址的空间存放的还是地址值。  
4. 新手们可以用“代入法”理解多级指针。

## 1.2 三级指针

```c
Type ***  pppname;
Type ***  pppname = 地址表达式;
```

定义语句意味着： 

1. pppname指向空间里可以存放一个或多个Type **类型的元素，这些元素是二级指针  
2. 而这些二级指针再次指向的空间里可以存放一个或多个Type*类型的元素，这些元素是一级指针  
3. 而这些一级指针再次指向的空间里可以存放一个或多个Type类型的元素  
4. 三级指针自己也是指针，也是变量，也一样有自身的内存空间，其空间中存放的也是地址值，只是以这个地址值为首地址的空间存放的还是地址值。  
5. 新手们可以用“代入法”理解多级指针。


继续联想应该还有：（和二级、三级指针一起统称多级指针）  
1. 指向三级指针的指针：四级指针  Type *** ppppname;  
2. 。。。。。。  
3. 指向N-1级指针的指针：N级指针  Type **...** pnname;

C语言语法理论上可以支持随便多少级的指针,实际项目中满足不成文的“事不过三”原则。



# 二、数组指针

将一种数组当成整体，再将这样的整体看成一个元素，指向这样元素的指针被称为数组指针，即指向数组的指针，即指针指向空间中存放着一个或多个数组

给数组指针类型起别名
typedef Type (*NewName)[M1][M2]...[Mn];

示例：
1. 有一个3行4列的整型二维数组，写函数求所有元素的平均值，要求函数中二维数组的操作使用数组指针操作



# 三、main函数形参

argc：
argv：

示例：
1. 求两个整数的最小公倍数，两个整数执行程序可执行文件时通过命令行传入

```c
#include <stdio.h>

int GetLCM(int num1,int num2);

int main(int argc,char *argv[])
{
	int x = 0;
	int y = 0;
	int z = 0;
	
	if(argc < 3)
	{
		printf("Usage is ./LCM 8 9\n");
		return 1;
	}
	
	sscanf(*(argv+1),"%d",&x);
	sscanf(*(argv+2),"%d",&y);
	
	z = GetLCM(x,y);    
	return 0;
}

int GetLCM(int num1,int num2)
{
	.....
}

```



1. 将字符串中所有大写字母改为小写字母，字符串通过main函数参数传入  

# 四、函数指针

任何类型的变量空间首地址都可以存储在相应类型的指针变量中。

C语言程序的代码以函数定义的形式组织，这些函数定义中所有代码被编译器按顺序翻译成很多条二进制指令，程序运行时这些指令被存放在代码区中。

代码区中，这些二进制指令也是按函数进行组织的，每个函数定义在代码区都有独自的一块空间，这片空间中顺序存放着该函数定义所对应的二进制指令，代码区就被这样的一块块空间分隔开来，程序由多少个函数定义组成，代码区就被分为多少份，每一份对应一个函数定义，函数名其实就是这份空间的首地址。（换句话就是说：函数名等价于存放代码区该函数对应的那份空间首地址的只读指针）

也就是说我们可以定义一种指针变量用来存放代码区某函数所在空间的首地址。这样的指针被称为指向函数的指针，简称函数指针。

函数指针的定义雷同与数组指针，不同于其它类型的指针定义，语法形式如下：

Type (\*函数指针名)(T1 t1,T2 t2,...,Tn tn);//未初始化形式的函数指针定义,不推荐
Type (\*函数指针名)(T1 t1,T2 t2,...,Tn tn) = 代码区空间地址;

例：
double (*pf)(int,char *) = NULL;
double (*pf)(int,char *) = &otherfunc;//&可以不写。只对函数名有效

给函数指针类型起别名也类似于给数组指针类型起别名
typedef Type (*NewName)(参数列表);//参数列表:逗号分隔的形式参数，可以没有参数名

定义形式告诉我们：

1. pf指向的函数必须具备如下特点：返回值类型为double，必须有两个形参：第一个参数类型为int，第二参数类型为char \*。
2. 即赋值给pf的函数名所对应的函数必须具备相同特点。
3. 返回值类型不一样、参数个数不同、参数类型不一样都意味着该函数指针类型的改变。

和变量访问分直接、间接访问一样，调用函数实际就是执行该函数在代码区的二进制指令，这也是访问，只是在访问代码区中该份空间的指令，也分直接、间接访问，只是轮到函数不叫访问改叫调用而已，即函数调用分为：

1. 直接调用：通过函数原名调用，即：函数原名(实参列表)，编译前决定调用哪一个函数
2. 间接调用：通过该函数在代码区的首地址调用，可以在程序运行过程通过给函数指针赋值来决定调用哪个函数，调用语法：

*同类型函数地址(实参列表)，*号可以不写，即：同类型函数地址(实参列表)

此时被调用的函数被称为回调函数。

函数指针最大的用途是作为函数形参，这样可以给一个函数传递处理某类问题的方法（即函数）。  
大体总结一下：
1. 基本类型形参：只能给函数传递一个数值
2. 非函数指针类型形参：可以给函数传递批量数据（一块空间的地址值）
3. 函数指针类型形参：只能给函数传递解决某类问题的方法

指针类型的用途总结：
1. 作为函数形参类型
2. 作为结构体成员类型
3. 作为函数返回值类型
4. 操作空间元素

示例：通用排序函数qsort




作业：
1. 有一个3行4列的二维数组，写函数求其中最大元素的行下标和列下标，行下标和列下标用结构体表示，要求函数中二维数组的操作使用数组指针操作
2. 写程序完成如下功能：有5个学员的数据，请采用插入排序算法，将n个学员按总分从高到低排序后输出。
   学员应包含如下数据成员：姓名、性别、语文成绩、数学成绩、英语成绩、总分。要求：
   1)程序自行初始化5个学员数据
   2)总分应由程序计算所得
   3)计算一个学员的总分写成独立函数
   4)输出n个学员所有数据写成独立函数
   5)排序过程中不可对存放5个学员的数组做任何改变，也不可借助同类另一数组完成，排序应对另一个包含5个元素地址值的数组进行
   6)插入排序写成可以针对任意类型数组的通用版独立函数
   7)禁止用下标法访问学员



# 五、给类型起别名 ---- typedef

typedef 已有类型  新名字;

对于结构体声明，不推荐使用，会掩盖是结构体的事实

给已有数据类型起别名, 非执行语句



特殊形式：

1. 给数组类型起别名
2. 给数组指针类型起别名
3. 给函数指针类型起别名





用法：
1. 基本类型、多级指针、结构体、共用体、枚举

  ```
  typedef 已有类型名 新名字;
  
  typedef unsigned int size_t;
  
  size_t x; ---> unsigned int x;
  
  typedef int ** PPINT;
  
  PPINT p1; ----> int **p1;
  ```

  

2. 数组类型

  ```
  typedef  Type 新名字[M];
  
  typedef double DARR[5];
  
  DARR arr1; ---> double arr1[5];  
  
  typedef  Type 新名字[M][N];
  typedef  Type 新名字[M1][M2]...[Mn];
  
  typedef float FARR[2][3][4];
  FARR arr2;
  ```

  

3. 函数指针类型

  ```
  typedef  T1 (*新名字)(形参列表);
  
  typedef int (*PFType)(void *,double);
  PFType pf; ----> int (*pf)(void *,double);
  ```

  

4. 数组指针类型

  ```
  typedef  Type (*新名字)[M1][M2]...[Mn]
  
  typedef double (*PARR)[3][4];
  PARR pd; ----> double (*pd)[3][4];
  ```

  


char 1
short 2
int 4
long 4 8
float 4
double 8
T *   4 8

64位系统
typedef int INT32;

16位系统:
typedef long INT32;


sizeof(INT32)



```
int (*parr[5])(void *,float) = ?

简化：
typedef int (*PF)(void *,float);
PF parr[5];
```



```
float * (*p[4])[3];

double * (*p)(float (*)[3],int);

简化：
typedef float (*PARR)[3];
typedef double *(*PF)(PARR,int);
PF p;
```



