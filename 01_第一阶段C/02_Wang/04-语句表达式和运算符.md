# 第一节 语句

语句分类：

1. 执行语句
2. 非执行语句

执行语句分类：
1. 由{}括起来的语句组，以及相应的头部整体被看做一条复合语句
2. 单条的独立语句，这类语句根据所起的主要作用分为：
   1). 变量定义语句
   2). 没有返回值或可忽略返回值的函数调用语句
   3). 表达式语句（本章）
   4). 跳转语句(goto、return、break、continue)
   5). 空语句仅一个分号:    ;             表示什么都不做
   	

x = (area = r * r * 3.14);

area = r * r * 3.14;
x = area;

if(表达式)
{
	
}

# 第二节 表达式

有运算结果的式子


表达式依据计算结果可分为：
1. 数值表达式（数学表达式）：运算结果为某一具体大小的数值 
2. 逻辑表达式（条件表达式）：运算结果只论成立不成立 或 是真（成立）是假（不成立） 或是非0（真）还是0（假）
3. 地址表达式：运算结果虽然也是某一具体大小的数值，但该数值为内存空间某一字节的编号即地址值

3 < 5
成立 ----- 非0 -----  真
不成立 ---- 0  -----  假

int x = 0;
&x
&(x+2)

x & y

表达式的组成要素有常量、变量、运算符和子表达式，
有没有运算结果是判断是不是表达式的标准，因此：

1. 运算符不是组成表达式必须的组成要素，单独的一个常量我们认为也是一个表达式，这个表达式的运算结果为该常量的值，
    同样，单独的一个变量我们认为也是一个表达式，这个表达式的运算结果为该变量的当前值。
2. 但是，我们在编程中由于任务需要，必须让计算机帮我们做很多运算，而这些运算必须使用到代表这种运算的运算符。
3. 一个表达式也可以成为另一个表达式的组成部分，其运算结果参与新表达式的运算。
4. 项目开发中不鼓励写太复杂的运算表达式，以免影响代码的可读性。

# 第三节 运算符

代表某种运算的符号，被称为运算符。C语言的运算符根据所需的操作数的个数被分为：

1. 一目运算符或一元运算符：如取地址运算符
2. 二目运算符或二元运算符：如加减乘除
3. 三目运算符或三元运算符：如条件运算符

C语言中的运算符并不是对所有类型的数据都有效、运算方式都一样，
哪种类型的数据能做哪些运算、如何做运算由数据类型来决定，
因此，我们后面每讲一种数据类型都要弄清楚这种类型支持的所有运算，
便于灵活运用到解决问题的代码里去。

本章实际在讲述基本数据类型支持的各种运算

# 第四节 针对变量名的基本运算

## 4.1 取地址运算  ----- & ---- 单目

用法：&变量名或相当于变量名的写法
功能：获取指定变量所在的内存空间的首地址
适用于所有能定义变量的数据类型

## 4.2 最简单的赋值运算  ----  =  ----- 双目

用法:  变量名或相当于变量名的写法 =  和变量同类型的表达式
功能：将表达式的运算结果放到变量的内存空间中

由赋值号连接的整个表达式的最终运算结果：左侧变量所得的最终值。

x = 2

使用注意事项：
1. 赋值号左侧只能是变量名或可以充当变量名的写法
 （也称空间别名，如后续章节的数组名加下标、间接访问运算符加地址值、结构体变量名加点再加成员名等等，其实各种访问运算符均可认为给对应空间起别名）
2. 赋值号两边的类型要尽量保持一致。
   当出现不一致时，表达式的运算结果会被转换成另一个值，变量所得的最终值可能与表达式的运算结果不一样。
   具体的转换过程见本章后面类型转换。
   

**实际上C语言编程遵循的第一大原则就是：类型一致化**！
赋值运算是第一个要讲究类型一致化的地方。

示例：交换



## 4.3 sizeof运算

sizeof运算符之前提到过，这里对其做进一步说明
使用方法：sizeof(数据类型名) 
          sizeof(变量名) 
	      sizeof(表达式)
          sizeof 变量名 或 sizeof 表达式  (不推荐)

其功能是：求对应类型的数据在内存中需要用多少字节的空间来表示，
                 其结果是size_t类型（即unsigned long型）
char ch;
sizeof(ch)
sizeof(char)
sizeof('a')

int a = 9;
int b = 0;
b = sizeof(a++);

a ?
注意事项：

1. 编译阶段进行的运算，其组成的表达式在目标代码中被其计算结果所代替，所以程序执行过程没有相应的运算，因此最后一种使用形式在项目中应杜绝
2. 计算结果的类型是unsigned long类型的别名size_t
3. 简单一致起见，项目开发中推荐前面两种使用方法





# 第五节 算术运算符

## 5.1 二目算术运算符

加法： ----> +
减法： ----> -
乘法： ----> *
除法： ----> /
取余： ----> %



特别注意：

1. +、-、*、/ ：如果运算结果太大，将结果赋值给某类型变量时可能会产生溢出
2.  /: 整除、浮点除法
3. %：整型数
4. 整除和取余时分母不能为0否则会导致程序崩溃，因此在实际代码做除法先对分母做是否为0的判断

## 5.2 一目算术运算符

自增 ----->   ++
自减 ----->   --

前置用法：
	++或--整型变量名或相当于变量名的写法
	
后置用法：
    整型变量名或相当于变量名的写法++或--
    
共同点：变量内容变为原内容+1或-1
不同点：
	前置：先+或-1，然后用新值作为表达式的计算结果
	后置：用老值作为表达式的计算结果，然后变量才+或-1

int x = 6;
int y = 0;

y = ++x; // x 7 ,  y 7
y = x++; // x 7 ,  y 6

x+++y 

(x++)+y
x+y
x++;  ====> ++x; 

x+(++y)
y++; ====>  ++y;
x+y

注意事项：
1. 自增自减运算符和赋值一样会改变变量的当前值，在**同一条语句中不要试图修改同一个变量多次**，否则结果会有二义性。
    如：int a = 5;
           a = 2 + a++; 
           a=? 
2. 调用函数时，如果一个变量在多个实参表达式中出现，结果会有二义性。
   如：int a = 5; 
          printf("%d,%d\n",a,a++);输出结果？
   
3. 不要太聪明，也不要试图弄明白类似这样的表达式究竟是怎么运算的：b = a+++c; 这样的代码是有二义性的，
    不同的编译器编译出来的程序运行结果可能是不一样的，你根本就不该写出这样的代码，
    在不违背以上两个原则的基础上多用()来明确你要做的运算，或者干脆将a++、++a这样的代码写成单独一行

4. 不要在sizeof()里做自增自减，因为sizeof运算是编译阶段由编译器进行的运算，编译后会被替换为相应的数值，程序执行不到自增和自减的。
    即不要写出这样的代码：sizeof(a++)  sizeof(x = 8)
    
    int a = 5;
    int y = sizeof(a++);
    
5. 在由逻辑与逻辑或连接的多个条件表达式中，
   除第一个外的后续表达式中不要做修改变量的操作，
   因为可能执行不到，见本章第七节

6. 由这两个运算符连接成的表达式的运算结果：后置为旧值，前置为新值

示例：输入星期，求下一天是星期几

# 第六节 位运算 ------> 整型 字符型

以下运算将对操作数的**每一个二进制位逐位做相应运算**，
操作数占多少个二进制位，由其类型决定。
这些运算只能对**整型和char型**操作数做位运算，
当有变量参与运算时，这些**位运算并不改变变量的当前值**，只是用当前值参与相应的运算

## 6.1 位逻辑运算符

一、按位与&

使用方法：整型表达式1 & 整型表达式2

其功能是：将整型表达式1的运算结果的每个二进制位 和 整型表达式1的运算结果的每个二进制位 逐位做位与操作

所谓位与操作是指二进制的两个位按下表产生对应的一位结果：（有0为0，全1为1）

位与   0    1 
    0     0    0    

?    1     0    1    

二、按位或|

使用方法：整型表达式1 | 整型表达式2

其功能是：将整型表达式1的运算结果的每个二进制位 和 整型表达式1的运算结果的每个二进制位 逐位做位或操作

所谓位或操作是指二进制的两个位按下表产生对应的一位结果：（有1为1，全0为0）

 位或  0     1    

?    0     0     1
?    1     1     1

三、按位异或^

使用方法：整型表达式1 ^ 整型表达式2

其功能是：将整型表达式1的运算结果的每个二进制位 和 整型表达式1的运算结果的每个二进制位 逐位做位异或操作

所谓位异或操作是指二进制的两个位按下表产生对应的一位结果：（相同为0，不同为1）

位异或   0     1 
     0       0     1
     1       1     0 

四、按位求反~

使用方法：~整型表达式

其功能是：将整型表达式的运算结果的每个二进制位逐位做位取反操作

所谓位取反操作是指二进制的位按下表产生对应的一位结果：（0变为1，1变为0）

原位   取反后 
0          1      
1          0      


6.2 位运算的运用技巧

一、构造辅助数（掩码Mask）来达到目的
a. 将某数某些指定位 置0，
如：将unsigned int型变量x的第3、6、9、12位置0（从0开始计数第n位）

unsigned int x = 9;

x = x & 0xFFFFEDB7;//0xFFFFEDB7是掩码

1111 1111 1111 1111 1110 1101 1011 0111 

b. 将某数某些指定位 置1，
如：将unsigned int型变量x的第3、6、9、12位置1（从0开始计数第n位）

unsigned int x = 9*12;

x = x | 0x1248;//0x1248是掩码

0000 0000 0000 0000 0001 0010 0100 1000 
0x1248

c. 将某数某些指定位 取反，
如：将unsigned int型变量x的第3、6、9、12位取反（从0开始计数第n位）

unsigned int x = 9*12;

x = x ^ 0x1248;//0x1248是掩码

d. 判断某数指定位置是0还是1，
如：判断unsigned int型变量x的第5位是0还是1（从0开始计数第n位）

unsigned int x = 9*12;

看x & 0x20运算结果是0还是非0


0010 0000 


二、寻找规律，运用规律达到目的

例：判断一个unsigned int型变量x是不是2的n次方
1   0000 0000  .. 0000 0001
2   0000 0000  .. 0000 0010
4   0000 0000  .. 0000 0100
    0000 0000  .. 0000 0011
8   0000 0000  .. 0000 1000

5   0000 0000  .. 0000 0101
    0000 0000  .. 0000 0100
.
看x & (x-1)运算结果是0还是非0

例：判断奇偶数  

6.3 移位运算符

一、左移

使用方法：整型表达式1 << 整型表达式2

其功能是：将整型表达式1的运算结果的每个二进制位向左移动n位（n为整型表达式2的运算结果），高位舍弃，低位补0

对于无符号整型在其取值范围内，每左移一位相当于乘以2，左移n位相当于乘以2的n次方

int x = 2；

x << 2

00 0000 0000 0000 0000 0000 0000 001000

00 0000 0000 0000 0000 0000 0000 000000
二、右移

使用方法：整型表达式1 >> 整型表达式2

其功能是：将整型表达式1的运算结果的每个二进制位向右移动n位（n为整型表达式2的运算结果），低位舍弃，高位补0或符号位

右移运算可能有两种：
1. 逻辑右移：高位补0
2. 数学右移：高位补符号位

和各类型的sizeof大小、浮点型在内存如何表示一样，这不由C语言决定，而是编译和运行程序的平台决定。
意味着对有符号整型做右移的代码是具有二义性的，项目开发中极度不推荐使用。

对于无符号整型在其取值范围内，每右移一位相当于除以2，右移n位相当于除以2的n次方（此处为整除的结果）。

int x = -1;

x >> 1
1111 1111 1111 1111 1111 1111 1111 1111 

x+++y

二义性代码
6.4 共同的注意事项
1. **雨露均沾**：不是只针对某一位，是操作数的所有二进制位都参与运算。因此所有位操作的第一步是弄清楚操作数占多少二进制位然后才运算，例如：对整型数1取反，结果不是0，而是-2或2的32次方减2（31个0和1个1组成）
2. 对于有符号整型**符号位也是参与运算**的，因此结果不是很直观的，
   会出乎意料的吓你一跳，因此**尽量只对无符号整型做位操作。**
3. 灵活构造、运用辅助操作数（掩码）来达到目的。

例：求两个整数的平均值（相同位+不同位/2）

int x = 3;
int y = 4;
...
(x + y)/2 ----> x/2 + y/2

0110    6
1100    12
0100  4

1010  10/2 5



程序执行次序：
1. 总体上是顺序执行
2. 跳转
    选择
    循环
    break continue goto return
    函数调用

# 第七节 简单的选择语句

C语言中可以由if关键字领头形成选择型复合语句，最简单的有如下两种形式：
一、单条件体形式

//之前语句...
if(表达式)
{//真条件体
    //...
}
//后续语句...

执行次序如下：

1. 执行完之前语句，计算表达式的值
    如果是数值表达式只论0还是非0，0为假，非0为真
    如果是条件表达式则看结果假还是真
2. 如果表达式为真，则执行“真条件体”，否则本步什么都不做
3. 继续执行后续语句

if和{}整体看做一条复合语句，这条语句读作：如果表达式为真做条件体否则什么都不做

二、双条件体形式
//之前语句...
if(表达式)
{//真条件体
    //...
}
else
{//假条件体
    //...
}
//后续语句...


执行次序如下：

1. 执行完之前语句，计算条件表达式的值，
2. 如果条件表达式为真，则执行“真条件体”，否则执行“假条件体”
3. 继续执行后续语句

此种形式，由if、第一对{}和else、第二对{}组合而成，整体看做一条复合语句，
这条语句读作：如果表达式为真执行真条件体中动作否则执行假条件体中的动作。

更多的选择语句语法形式见下一章。



下回分解

# 第八节 比较运算符

也称关系运算符，即用来比较大小关系的运算符，
很显然这样的表达式运算结果是逻辑值，C语言中有六个符号分别表示：

`>大于、<小于、>=大于等于、<=小于等于、==等于、!=不等于`



使用方法：表达式1 比较运算符 表达式2

其功能是：如果表达式1的值和表达式2的值满足比较运算所描述的大小关系，则整个表达式结果为真，否则结果为假


这些比较运算符都是二目运算符，初学者特别要注意：
1. ==等于和=赋值的区别

2. 每个比较运算符只能单独使用，不可以像数学式的连写：3 > a > 0，这样的写法不正确，
    需要用逻辑运算符配合来达到目的：     3 > a && a > 0
    
3. 由这六个运算符连接的表达式的运算结果是逻辑值（只论成立不成立）

4. 在项目中，浮点型数与0比较是否相等，如果有精度要求需按规定的精度进行，不要直接进行比较，即：
   
```c
float x = 表达式;
if(x == 0.0) 或 if(x != 0.0)   //不正确
{
    //...
}
   
   #include <float.h>
   float x = 表达式;
   if(x < 0.00001&& x > -0.00001)
   {//条件成立认为x为0
   }
```

   


小技巧：常量和变量比较是否相等时，将常量写在==之前。

```c
int x = 2；

//改变x的值。。。
if(x == 1)
{
	.....
}

if(1 = x)
{
     .....
}
```



# 第九节 逻辑运算符

## 9.1 逻辑与&&

使用方法：条件表达式1 && 条件表达式2   
         条件表达式1 && 条件表达式2 && 条件表达式3  && ... && 条件表达式n

其功能是：连接两个或更多的条件表达式，只有所有条件表达式的值为真，所连接的整个表达式结果才为真，否则为假

注意事项：
1. 逻辑短路：从左至右依次计算每个条件表达式，一旦遇到有为假的表达式，则整个表达式的运算结果为假，
   后续表达式将不再被计算，因此不要在&&连接的表达式中做更新变量值的运算，因为这个操作可能没有被执行
2. 其本质是对逻辑值（真或假）的“并且”运算：

&&（逻辑与） 真      假  
        真             真      假
        假             假      假
int a = 9;
int b = 0;

b != 0 && a++ > 8
a?

## 9.2 逻辑或||

使用方法：条件表达式1 || 条件表达式2   
         条件表达式1 || 条件表达式2 || 条件表达式3  || ... || 条件表达式n

其功能是：连接两个或更多的条件表达式，只要任一条件表达式的值为真，所连接的整个表达式结果就为真，否则为假

注意事项：

1. 逻辑短路：从左至右依次计算每个条件表达式，一旦遇到有为真的表达式，则整个表达式的运算结果为真，
    后续表达式将不再被计算，因此不要在\|\|连接的表达式中做更新变量值的运算，因为这个操作可能没有被执行
2. 其本质是对逻辑值（真或假）的“或者”运算：

||（逻辑或） 真      假   
          真      真      真
          假      真      假

## 9.3 逻辑求反！

使用方法：!条件表达式
其功能是：如果条件表达式的结果为真则整个表达式的运算结果为假，
          而如果条件表达式的结果为假则整个表达式的运算结果为真。



课堂练习：输入一个整数，判断其是否为3和7的整数倍，
        若是输出yes，否则输出no



# 第十节 偷懒用的复合赋值

这是一些用来偷懒的运算符只是为了少敲一遍变量名，
在没有鼠标的编程年代，这些运算符确实提升一点程序员工作效率，
而在copy、paste的现在它们的作用也仅是让表达式看上去短了一些，
你可以完全不去使用它们。
这些复合赋值运算符由一个二目算术、位运算符和赋值号组成
用法如下所示：
 变量名 ?= 表达式   （?可能是+、-、*、/、%、&、|、^、<<、>>十个二目运算符其中之一） 

 += -= *= /= %= &= |= ^= >>=  <<=
这种写法完全等价于下面的写法：变量名 = 变量名 ? 表达式 

即先计算表达式的值，然后用此值和变量当前值进行相应的运算而产生一个新值，并将新值赋值给该变量


x = x + 2;
x += 2;

array[8].arr[i]

一、算术复合赋值运算符

```c
+=：加赋值       x+=6   <====> x  = x + 6
-=：减赋值        x-=6    <====> x  = x - 6
*=：乘赋值        x*=6    <====> x  = x * 6
/=：除赋值        x/=6    <====> x  = x / 6
%=：取余赋值   x%=6   <====> x  = x % 6
```

二、位运算复合赋值运算符

```c
&=：与赋值       x &= 6      <====> x  = x & 6
|=：或赋值        x |= 6         <====> x  = x | 6
^=：异或赋值    x ^= 6      <====> x  = x ^ 6
<<=：左移赋值  x <<= 6   <====> x  = x << 6
>>=：右移赋值  x >>= 6   <====> x  = x >> 6
```


# 第十一节 逗号运算符

逗号,用于连接多个表达式，其本身不做任何运算，但它指明运算顺序

使用方法：表达式1,表达式2,表达式3,.....,表达式n

其功能是：先计算表达式1，然后计算表达式2，再然后计算表达式3......最后计算表达式n

注意事项：
1. 整个表达式的值为最后一个表达式n的值
2. 与一行定义多个变量以及函数形参、实参列表等等中的逗号,不同，
   它们只是相应场合的分隔符，不是逗号运算符
3. 前一个表达式的副作用，对后续其它表达式有效

int a = 2;
int b = 3;
int c = 0;
a++,b+=4,c=a+b;//c的最终值为10




# 第十二节 数值类型转换

```c
int x = 10;
float f = 2.1f;
double d = 8.2;
char ch = 'a';
short sh = 2;

x*sh + f / 2l + d + ch


x*sh + ch *2u
```



### 12.1 自动类型转换
当我们在一个表达式中有多个不同类型的操作数出现时，那么这个表达式的运算结果是什么类型呢？
当然我们应该需要尽量避免这种情况发生，但是很多情况是没法避免的，
C语言编译器在遇到这种情况时，它会按一定规则来统一类型（自动类型转换），
下面我们从两种情况来描述C语言的自动类型转换的规则：

- 无赋值运算的表达式
  - 所有char 和 short提升为int，float提升为double
  - 任何运算的两个值被转换成两种类型中较高的级别，类型级别从高到低为：
    double、unsigned long、unsigned int、long、int进行提升，
    如果long和int不等长，则long高于unsigned int，
    此时有些整负值可能变为很大的正值，程序员自行保证这种转换的合理性。
- 赋值号两边的转换规则（包括隐形赋值：函数传参、执行带表达式的return语句），
  遵循类型一致化原则，即将赋值号右边表达式的值类型转换为左边变量的类型，具体如下：
  - 浮点型赋值给整型：取整（不会发生四舍五入）后赋值（损失小数部分）
  - 整型赋值给浮点型：加.0成为浮点数后赋值（无损失）
  - 整型大类型赋值给小类型：按字节截取（可能有损失）
  - 整型小类型赋值给大类型：提升后无损赋值（无损失）
  - double赋值给float：太大了值变成无穷大inf（可能有损失）
  - float赋值给double：提升后无损赋值（无损失）
  - 无符号整型赋值给有符号整型：太大了变负（可能值变）
  - 有符号整型赋值给无符号整型：负数变大数（可能值变）

变量名 = 表达式
### 12.2 强制类型转换
自动类型转换是由C语言编译器自动进行，这让程序员很容易忽略一些值的改变，运算结果常常愕然。
为了让程序员自己根据实际需要进行类型转换，C语言提供一种运算符――强制类型转换运算符，
这不是一个运算符，是一系列运算符，它们是一目运算符，
这些运算符的写法为：(数据类型名)。
数据类型名可以是除void以外的任何C语言支持的类型。


(int)
(char)
(float)
....
(Type)表达式


使用方法：(数据类型名)表达式
其功能是：将表达式值的类型转换成圆括号中指定的数据类型，转换规则同赋值号两边的转换规则



## 第十三节 条件运算符
C语言中一种简便的if-else逻辑式语句，唯一的三目运算符
使用方法：条件表达式1?表达式2:表达式3
其功能是：先计算条件表达式1的值，
         如果为真整个表达式的值与表达式2的值相同，
         如果为假整个表达式的值与表达式3的值相同

x = 条件表达式1?表达式2:表达式3;
语句等价于如下代码写法：
if(条件表达式1)
{
    x = 表达式2;
}
else
{
    x = 表达式3;
}


注意事项：
1. 这个运算符在适应场合起简化代码的作用
2. 表达式2和3任一被选中则计算该表达式，而另一表达式并不被计算，非常像&&和\|\|

例：若w=1,x=2,y=3,z=4,则条件表达式w<x?w:(y<z?y:z)的值为

## 第十四节 符号运算符

负号-也可以是一个单目运算符！
（实际+也可以是单目运算符，只不过没有任何作用，我们忽略它）

使用方法：-有符号数值表达式

其功能是：取数值表达式值的相反数（正变负，负变正）

## 第十五节 运算次序

一个表达式中如果有多个不同运算符，则运算的先后次序按C语言规定的运算符优先级来决定

而一个表达式中如果有多个相同运算符，则运算的先后次序按C语言规定的此运算符的结合方向来决定

你无须背诵运算符优先级和结合方向，但你要记住的以下几点：
1. 善用()圆括号由自己掌控运算次序，被()括住的子表达式具有最高运算的优先级
2. 与()具有最高优先级的还有数组下标访问[]、结构体变量名成员访问.、结构体指针成员访问->、函数调用、后置自增与自减
3. 其它单目运算符具有次高优先级、强制类型转换具有第三高优先级
4. 逗号运算符优先级最低，赋值运算符次低，条件运算符第三低
5. 位于中间优先级的运算符总体按：算术运算 高于 比较运算 高于 逻辑运算
6. 第二、三高和第二、三低优先级的运算符结合方法为从右向左，其它运算符从左向右

口诀：
- 函数调用加括号，成员后置把雄傲；（函数调用要有圆括号，同时也指圆括号和方括号）
- 老二单目一大家，老三强转自己保；（喻指程序员自己保证类型转换导致的值变合理性）
- 逗号运算最低调，赋值倒二不牢靠；（喻指注意自动类型转换引起的值变）
- 条件运算像杨戬，能力再强倒数三；（条件运算是三目运算符，也有教育人有能力也要有态度）
- 算术先于比大小，然后逻辑才来到；
- 老二老三不服管，倒行逆施搞造反；（喻指顺数、倒数第二、第三的运算符结合方向从右向左，而其它运算符都是从左向右的）
- 还有眯瞪拎不清，多加括号来分清；
- 别人式子看着彪，只能查阅优先表；（看别人写的表达式太复杂，只能去查运算符优先级表去弄清）






