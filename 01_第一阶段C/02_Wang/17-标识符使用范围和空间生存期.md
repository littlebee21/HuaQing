# 一、标识符使用范围

```
作用域：名称可直接使用的代码范围
1. 局部作用域:所属{}局部范围内
2. 文件作用域:名称定义开始到.c文件尾

函数名：文件作用域  函数定义的函数头所在行开始 -------- 函数定义所在.c文件尾

变量名：
	1. 函数体内定义的变量-----局部变量  
	   局部作用域 从定义语句开始 ------ 变量定义语句隶属的{}结尾 
	2. 函数定义的函数头形参列表里定义的变量------函数形参  
	   局部作用域  整个函数体范围
	3. 不在任何函数定义范围内定义的变量 ----- 全局变量  
	   文件作用域  从定义语句开始 ---- 变量定义语句所在.c文件尾
	   
	   全局变量定义语句执行时机：可以认为全局变量定义在程序的main函数被系统调用前，已被执行
	   因此全局变量所占用的内存空间在程序main函数调用前已经存在，在程序退出执行时空间被系统回收（整个程序运行期 ----- 静态数据区（简称为数据区） ）
	   
	   全局变量定义如果未初始化，系统会将其自动初始化为相应的0值。

类型名：（包括typedef起的别名）
	1. 设计语句在某函数体内（项目中不推荐） ---- 局部作用域  从设计语句开始 ----  隶属的{}结尾    
    2. 设计语句在所有函数定义之外 ------- 文件作用域   从设计语句开始 ----  当前.c文件尾
    
宏名：
	文件作用域   从宏定义开始 ----- 当前.c文件尾 或 遇到对应#undef
```

```
链接性：作用域之外可不可以使用该名称，如能使用范围有何限制，使用前需要做什么
1. 无链接性
2. 内部链接性：作用域之外，但在当前.c文件范围   ------ 先声明后使用	 
3. 外部链接性：作用域之外，任何位置都可以（定义语句之前但在当前.c文件内 和 其它所有.c文件）------ 先声明后使用

函数名
 1> 内部链接性
 	函数定义：  
 		static Type 函数名(形参列表)
 		{
 		}
 	声明：static Type 函数名(形参列表);
 	
 2> 外部链接性
 	函数定义：  
 		Type 函数名(形参列表)
 		{
 		}
 	声明：Type 函数名(形参列表);
 		 extern Type 函数名(形参列表);
 	
变量名
	1. 局部变量  ----- 无链接性
	2. 函数形参  ----- 无链接性
	3. 全局变量 
		1> 内部链接性：
			定义语句语法： static Type 全局变量名 = ...; 
			             static Type 全局变量名;
			声明语句：static Type 全局变量名;
		2> 外部链接性：
			定义语句语法： Type 全局变量名 = ...; 
			             Type 全局变量名;
			声明语句：
					extern Type 全局变量名;

类型名:无链接性

宏名：无链接性
```

标识符的使用范围 = 作用域 + 链接性

# 二、内存空间生存期

程序运行过程中的内存空间来源：

1. 变量定义
2. 动态分配

```
空间的生存期：空间开始存在的时刻 ----------- 空间被回收的时刻
程序只能使用处于生存期内的内存空间
1. 自动存储时期
	auto ---- 可省略不写 
	从定义语句开始 ----- 到所隶属的复合语句执行完（系统将自动回收对应的内存空间）
2. 静态存储时期 ------ 整个程序运行期
	程序的main函数被调用前系统已经为程序分配好  ------ 程序运行结束（系统才回收这些空间）
3. 动态存储时期
	从成功调用malloc函数开始 -------- 对对应空间调用free函数
```

程序运行过程中使用的内存被操作系统划分四个区域（划分原则1：放数据还是放指令 划分原则2：按生存期）：

1. 栈区（数据 --- 自动存储时期）：非static局部变量定义、函数形参

   a. 任何一个程序的栈区大小是有限的。（由操作系统指定固定大小，64位桌面版Linux为8M）

   因此一个程序函数嵌套调用（如果是调用自己就称递归）的层次受栈区大小的限制

   一旦程序栈区被用完，就会产生栈溢出错误，导致程序崩溃

   b.非static局部变量定义未初始化其值是野值（不确定的值）

      

2. 堆区（数据 --- 动态存储时期）：malloc动态分配的

   动态分配的空间程序一旦不使用应该立即调用free进行释放，延后多长时间，就会造成多长时间的内存泄露

   

3. 数据区（数据 --- 静态存储时期 ）：全局变量、static局部变量、字符串常量

   1> 可读可写分区

   ​	1>第一部分（BSS- Block Started by Symbol 段）（ZI_data）：初始化为零、未初始化（系统自动初始化为零）

   ​	2>第二部分（非BSS段）（RW_data）：初始化为非零的

   2> 只读分区（RO_data） -------- 只能读不能改，一旦修改程序就崩溃

      字符串常量、const修饰的全局变量

   特点：

   1> 未初始化的全局变量、非static局部变量会被系统自动初始化为零

   2> 项目开发中，一般应该尽量避免使用全局变量和static局部变量 

4. 代码区（指令 ----- 静态存储时期）：各个函数定义对应的二进制指令

   1> 只读

   2> 函数指针所指向区域

# 三、全局变量

定义在所有函数定义之外的变量被称为全局变量

全局变量定义语句在程序main被调用前已经被执行完成

```
两种全局变量：
1. static全局变量
   static Type 变量名;
   static Type 变量名 = ......;
   
2. 非static全局变量
   Type 变量名;
   Type 变量名 = ......;
   
变量名的使用范围：
    非static全局变量：作用域 + 当前.c作用域之外 + 其它.c文件
    static全局变量：作用域 + 当前.c作用域之外
    
    作用域之外使用前需进行声明：
    非static全局变量声明：
    	extern Type 变量名;
    static全局变量声明：
    	static Type 变量名;
    	
空间生存期：
	静态存储时期 ----- 整个程序运行期

```

# 四、static局部变量

定义位置同非static局部变量

```
T 函数名(形参列表)
{
	static Type  变量名; //被系统自动初始化为0
	static Type  变量名 = .... ;
}

1. 变量对应的内存空间的生存期变为静态存储时期
2. 每次函数被调用，static局部变量定义不会被再次执行，因为static局部变量定义语句在程序的main函数被调用前已经被执行了，因此不会被再次执行
3. 函数每次被调用时用的static局部变量空间都是同一块空间
4. static局部变量的名称使用范围和非static局部变量一样：作用域 
```



**函数返回值类型为指针类型（即返回的是一块内存空间的地址值）时的几种情况汇总：**

**总原则：在函数返回后，返回的地址值所代表仍然存在**

1. 返回的是全局变量空间的地址值
2. 返回的是static局部变量空间的地址值
3. 返回动态分配的空间地址
4. 返回某个指针类型的形参指向的空间地址



C语言编程的两大原则：

1. **类型一致化**
2. **程序使用内存空间必须是程序员已知可控的内存空间**

# 五、static函数

```
函数定义分为两类：
1. static函数：
	定义语法：
		static T 函数名(形参1类型 形参1名字,形参2类型 形参2名字,...,形参n类型 形参n名字)
		{
			.....
		}
	名称使用范围：作用域 + 当前.c
	作用域之外使用（调用、将函数名作为地址值使用）需要先声明
	声明语法：
		static T 函数名(形参1类型 形参1名字,形参2类型 形参2名字,...,形参n类型 形参n名字);
2. 全局函数、非static函数、外部函数：
   定义语法：
		T 函数名(形参1类型 形参1名字,形参2类型 形参2名字,...,形参n类型 形参n名字)
		{
			.....
		}
	名称使用范围：作用域 + 当前.c + 其它.c文件
	作用域之外使用（调用、将函数名作为地址值使用）需要先声明
	声明语法：
		extern T 函数名(形参1类型 形参1名字,形参2类型 形参2名字,...,形参n类型 形参n名字);
	    T 函数名(形参1类型 形参1名字,形参2类型 形参2名字,...,形参n类型 形参n名字);
```



# 六、关键字----static

1. 修饰全局变量 ----- 将全局变量的外部链接性 改为 内部链接性

2. 修饰局部变量 ----- 将局部变量的生存期由自动存储时期 改为 静态存储时期
3. 修饰函数定义 -----  将函数的外部链接性 改为 内部链接性

# 七、关键字----const

const在C语言应该理解成 只读的变量

作用是修饰变量定义，被其修饰的变量只能**通过变量名**去读而不能**通过变量名**去修改

const修饰变量在定义一定要进行初始化。

1. 修饰局部变量

   不能**通过变量名**去直接修改，否则编译会出错

   但可以通过地址去间接修改

   

2. 修饰全局变量和static局部变量

   不能**通过变量名**去直接修改

   也不能通过地址去间接修改

3. 修饰指针类型的形参：告诉调用者，该形参指向空间在整个函数调用中不会被修改  ----- 值参数

   ```
   const 形参类型 * 形参名
   形参类型 const * 形参名
   ```



const修饰指针类型的用法：

```
1. 修饰一级指针
   const T *pt;//不能通过pt指针名去修改其指向空间的内容 ------ 意味着指向空间只读（不太准确）
   T const *pt;//不能通过pt指针名去修改其指向空间的内容
   
   T * const pt;//不能通过pt指针名去修改其自身空间的地址值 ----- 意味着指针指向不可变（不太准确）
   
   const T * const pt;//既不能通过pt指针名去修改其指向空间的内容（第一const的作用），也不能通过pt指针名去修改其自身空间的地址值（第二个const的作用）
   
   读法：
   1> 去掉T
   2> 将*理解成间接访问运算符
   3> 如果有多个const，则挨个理解，每个从const开始读，const之前内容忽略
   
2. 修饰二级指针
const T **ppt;//不能通过ppt指针名去修改其二级指向空间的内容
T const **ppt;//不能通过ppt指针名去修改其二级指向空间的内容

T * const *ppt;//不能通过ppt指针名去修改其一级指向空间的内容

T ** const ppt;//不能通过ppt指针名去修改其自身空间的地址值

const T * const * ppt;//不能通过ppt指针名去修改其二级指向空间的内容,也不能通过ppt指针名去修改其一级指向空间的内容
T * const * const ppt;//不能通过ppt指针名去修改其一级指向空间的内容,也不能通过ppt指针名去修改其自身空间的地址值
const T ** const ppt;//不能通过ppt指针名去修改其二级指向空间的内容,也不能通过ppt指针名去修改其自身空间的地址值

const T * const * const ppt;//不能通过ppt指针名去修改其一级指向空间的内容,不能通过ppt指针名去修改其二级指向空间的内容,也不能通过ppt指针名去修改其自身空间的地址值
```



# 八、关键字-----volatile

volatile ---- 易变的

修饰变量定义 ---- 意味着被修饰的变量容易被多种不同方式同时进行修改，要求编译对其空间访问不做任何优化，每次均是访问对应内存。

作用是阻止编译对相应变量的空间访问做优化



# 九、关键字 ----- register

register ----- 寄存器

修饰函数形参和非static局部变量，意味着该形参或非static局部变量**可能**不占用内存空间，而占用一个cpu内存的寄存器，目的是为了加快对该形参或非static局部变量的访问速度

register关键字不是强制性质，只是建议性质的

被register关键字修饰的变量，**不能对其进行取地址运算**

被register修饰的非static局部变量和函数形参的sizeof不能大于单个CPU寄存器的字节数大小

但是现在的编译器大部分做得都很智能，即使不写register关键字，在没有volatile修饰且没有地址运算的场合且有空闲寄存器时，编译器也会自动对其进行register式的优化

# 十、大汇总

见表格

见内存布局图