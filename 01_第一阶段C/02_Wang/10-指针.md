C语言的灵魂――指针

在数组那章咱们提到，在项目中我们经常需要对很多同类型元素做一些管理操作，
比如：在数组中插入新元素、删除元素、找最大元素等等，
如果将这些操作写成独立功能的函数，意味着这些函数需要处理批量的元素，
那么怎么样将批量的元素传递给函数呢？要知道一个基本类型的形参只能传递给函数一个数值而已。

再有，如果一个函数产生多个结果又如何反向传递给调用函数的地方呢？
要知道基本类型作为函数返回值类型通过return语句只能给调用处一个数值而已。

这两个问题的解决，都得通过本章的指针类型来解决的。
而指针类型也是C语言和C++不同于其它高级编程语言独有的数据类型。

# 第一节 再论内存和地址

## 1.1 内存的作用

回想一下，前面所讲的内存，我们知道内存的主要作用是：  

1. 用于存放程序运行过程用到的指令  
2. 用于存放程序运行过程用到的数据

姑且先不论指令，内存中存放的数据，无非就是一些数字：  

1. 数值：各种整型、浮点型、字符型的数字，这样的数字含义多变，需要根据程序要解决的问题上下文来确定
2. 地址值：内存中每一个字节的编号值，也是一个数字，这样的数字含义已经明确不过。

内存中存放的数值有类型之分，如：8种整型、2两种浮点型、1种字符型、或由它们组合而成的构造类型

而内存中存放的地址值也有类型之分的，即地址类型，
比如：8种整型地址、2种浮点型地址、1种字符型地址、void类型地址或各种构造类型的地址等等，

## 1.2 地址的类型

在C语言中地址类型用如下形式表示：Type *

一种求得Type类型地址的方法(不是唯一的哦！)是：对Type类型的变量做取地址操作(&)

Type *读作Type类型的地址，**以此类型地址值为首地址的内存空间中连续存放着一个或多个Type类型的元素**。这句话有两层意思：  

1. 地址值所代表的内存空间中可能存放着一个Type元素或连续存放着多个Type元素，究竟多少个由地址值来源方式决定。  
2. 同样的一个地址值，即该字节单元在内存中的编号值是一样的，如果地址值的类型不一样，则以该字节为第一个字节的连续sizeof(Type)个字节中保存的二进制位的作用也是不一样的。

C语言有一种特殊的地址类型称为通用地址类型即void *，此时的void我们理解成“不确定”，而不是“没有”或“空”，因此所谓void *类型的地址或通用地址就是以此类型地址值为首地址的内存空间中存放的元素类型暂时不确定，意味着：  

1. 不可以对`void *`类型的地址做间接访问：`*void类型的地址表达式`---->不合法或无意义  
2. 此类型地址值为首地址的内存空间中二进制位作用暂时不确定。  
3. 你需要根据情况给这个地址值重新指定其它类型如：NewType *（通过地址类型的强制转换运算来实现），然后才能以NewType类型的方式访问指向空间中存放的NewType类型的元素

## 1.3 访问内存中元素的方法

之前，我们定义一个基本类型的变量，意味着这个变量空间中可以存放一个指定类型的元素。我们如果想要使用这个元素，可以用这个空间的名字（即变量名）来代表其中存放的当前元素。这种通过变量名来访问元素的方法被称为直接访问。顾名思义，应该还有另一种访问方法叫间接访问了？没错！

这种方法通过元素所在空间的首地址来访问，而这个首地址的类型需要与元素的类型一致，C语言通过一个新的运算符来达到目的，这个运算符也被称为间接访问运算符（地址访问运算符），这个运算就是`*`，是一个一目运算符，怎么又是`*`号？这个我们下面再说，先看看这个运算符的用法：

`*Type类型的地址表达式`，其功能是：通过Type类型的地址访问该地址值为首地址的内存空间中存放的Type类型的元素。

总之，访问内存中元素的方法有两种：  

1. 直接访问：即通过元素所在空间的名字，用这个名字直接代表该元素  
2. 间接访问：即通过元素所在空间的首地址，用  `*Type类型的首地址`  来代表该元素

换句话说，一块内存空间，首地址已定，地址类型一旦确定，就可以通过此类型的这个地址值来访问该空间，也可以认为 `*Type类型的首地址` 是这块内存空间的绰号（别名、非正式名称）

# 第二节 指针的概念和sizeof

## 2.1 什么是指针

指针类型就是地址类型的别称，这种类型的变量称为指针变量简称指针。

通俗地讲，所谓指针就是存放地址值的变量

一个指针变量，不能像之前基本类型的变量一样仅用一个类型关键字比如pointer来表示其类型，
即像这样来定义一个指针变量：pointer px;是不够的，
这样的形式只能告诉我们这个变量空间里（即指针变量自身的空间）存放的是一个地址值，
而以这个地址值为首地址的空间（称为指针指向空间）里存放的元素是什么类型是没法知道的，
或者说，指针指向空间里二进制位都起什么作用是没法知道的。
而我们编程时因为两个原因，我们需要知道指针指向空间的类型：  

1. 通过指针中存放的地址值去访问指针指向空间中的内容时必须要知道指向空间的类型  
2. 对指针中存放的地址值做一些运算时必须要知道指向空间的类型

新手们要注意的是，指针和基本类型变量有一些共性，你需要时刻浮现在你的脑海：  
1. 指针是变量，其本身和基本类型变量一样，有自己的内存空间，也是一个存放某种东东的“器皿”，
   只不过这样的器皿里只能存放指定类型的地址值。  
2. 指针自身的空间里也是用多位的二进制0、1来描述地址值的，
   地址值的编号从0开始到平台支持的最大内存容量减一，也是一个数字，
   更准确地说是无符号整型的数字，
   但这个数字你不可以将它认为是其它含义（如：某物品的重量、某人的年龄、路程的长度等等），
   它只能被认为是内存中某一字节的编号（抽屉的编号，即地址值）



**所谓指针，全称为指针类型的变量（地址类型的变量），这些变量空间（指针自身空间）中存放的是另一块内存空间（指针指向空间）首地址**



## 2.2 sizeof(Type *)

那么，需要多少个二进制位来描述一个地址值呢？即指针类型的sizeof怎么计算呢？这依赖于平台，一般地：  

1. 32位机以及以下平台大多数是4字节，即用32个二进制位来描述一个地址值，sizeof(Type *)-->4  
2. 64位机平台大多数是8字节，即用64个二进制位来描述一个地址值,sizeof(Type *)-->8

注意，sizeof(Type *)的结果与Type是无关的，一个平台上，不论Type是何类型，由其和*号组成的指针类型Type *的sizeof都是一样的！！！

# 第三节 指针的定义和初始化

## 3.1 指针的定义和初始化语法

指针变量的定义与基本类型的变量定义语法形式上差不多：

Type *pointername;//没有初始化
Type *pointername = Type类型的地址表达式;


第一种形式，在项目中不被推荐，与基本类型的变量定义一样一个指针如果在定义时没有初始化，其中存放的地址值也是不确定的地址值（野地址，以该地址值为首地址的内存空间对程序员而言是未知不可控的，存放野地址的指针被称为野指针），换句话说，指针指向的位置不确定，这是非常危险的，C语言要求我们程序中所有用到的内存空间对程序员而言必须是已知的、可控的。  
第二种形式，是项目中推荐的定义方式，Type类型的地址表达式可以是：  

1. 对Type类型的变量取地址所得  
2. 将其它类型的地址强制转换所得（注意语义的合理性）  
3. 某些函数返回的Type类型的地址  
4. Type类型的一维数组名或Type类型数组中的某个元素的首地址，
   Type类型的一维数组名在表达式中单独出现时其相当于存放下标为0元素所在空间首地址。  
5. 已知的Type类型的地址值经过一些数学运算所得（比如加减某个整数后所得）  
6. NULL,被称为空地址，其本质是内存单元编号为0的哪个字节的地址，所有有操作系统的平台编译器认为0号字节有特殊作用，只能被操作系统在特定时候使用，我们的代码不可以操作（读或写）这个字节，如果操作了操作系统立即让你程序死翘翘。一个指针变量空间里如果存放的是空地址，此时该指针就被称为空指针，与野指针不一样，野指针是指向的空间未知不可控，而空指针可以认为没有指向任何地方。一个没有指向任何地方的指针当然是不能用来间接读写的。

新手注意：不要在一行以如此形式：Type *p1,p2,p3;定义多个指针变量，这样的写法虽然语法上是允许的，但编译器却认为p1是Type型指针，p2、p3是Type型变量，因此，你如果非要一行定义多个指针变量可以写成这样：Type  *p1、*p2、*p3;

为什么是这样的呢？那是因为编译器将变量定义语句中的*号认为是变量名的开头标记，这个标记告诉我们这个变量空间里存放的一个地址值，p1是指针，而p2和p3的开头没有此标记，它们不是指针而是Type类型变量。换一种说法，编译器认为*p1是另一块空间的别名。新手们为了避免这种误会，应该紧跟潮叔的习惯：一行只定义一个变量，同时对该变量进行初始化。

## 3.2 指针定义语句的作用

再来“套路”一下，指针既然也是变量，只是它有点特殊而已，那它的定义语句作用是否也像基本类型的变量定义语句那样呢？看下面，指针定义语句的作用：  

1. 分配 sizeof(Type *)个字节的内存空间（指针自身空间）  
2. 给空间命名为指针变量名（指针自身空间）  
3. 空间（指针自身空间）二进制位的作用是描述一个无符号整数，该整数的含义是另一内存空间（指针指向空间）第一个字节的编号（即地址值）  
4. 指向空间中的二进制位作用是从首地址开始每sizeof(Type)个字节存放一个Type类型的元素

## 3.3 C语言中的*号

`*`号在C语言中比较有趣，有以下几个意思：  

1. 作为双目运算符时，其表示乘法  
2. 作为单目运算符时，其表示间接访问，此时其后只能紧跟地址表达式  
3. 在变量定义语句中，其被认为变量名的一部分，存放地址的特殊标记，或`*p`是p指向空间的别名  
4. 在sizeof运算和强制类型转换时，其被读作“地址”

其实，2、3、4都是地址相关的理解和运用而已，相互之间并不矛盾，就看你习惯从哪种角度理解而已：  

1. 别名法理解指针  
2. 地址法理解指针  
3. 间接访问法理解指针

以下情况你可以根据自己的喜好选择理解方法，但建议新手按我的理解来，不太容易犯错：  

1. `*地址表达式`出现在赋值号左边：别名法  
2. `*地址表达式`出现在赋值号右边：间接访问运算符  
3. `sizeof(Type *)`、地址类型强转`(Type *)地址表达式` 时：读成地址  
4. 变量定义语句时随便哪种都可以，建议读作地址，但要注意：一行只定义一个变量，并对其进行初始化

## 第四节 指针相关的运算

对指针进行的运算，除了4.1和4.2针对的是指针本身空间，其它都是对其空间保存的地址值的运算

## 4.1 赋值

Type *p = NULL;  

指针变量名可以直接出现在赋值号的左边： 
    `p = Type类型的地址表达式`
作用是改变指针p自身空间中存放的地址值，或称让p指向以新地址（新地址是Type类型地址表达式的运算结果）为首地址的内存空间

注意：与表达式:
      `*p = Type类型表达式`
不同，该语句的作用是修改p指向空间的内容为新内容。

C语言中地址值的最原始来源无非以下几种：  

1. 空间分配来自动态分配（见后续章节）  

2. 空间分配来自静态分配，即通过变量定义语句所获取的空间：  
   
   1）Type类型变量取地址（这个变量也可以是一个结构体或共用体变量中一个Type类型的成员） 
   2）Type类型数组中某元素的首地址（这个数组也可以是一个结构体或共用体变量中Type数组类型的成员） 
   3）由2中的地址值经过运算所得

```c
double d = 1.2;
double arr[5] = {1.1,2.2,3.3,4.4,5.5};
double *pd = NULL;

pd = &d;

pd = &arr[0];//p = arr;

pd = &arr[2];//p = arr + 2;  数组名在表达式中单独出现时相当于下标为0的元素的地址

```



## 4.2 取指针的地址

指针变量是一种特殊的变量，特殊在：其空间中存放的是地址值，但其仍然是变量，变量具有的特性它都具有，因此：  

1. 变量有专属的内存空间，指针也有专属的内存空间  
2. 变量的专属内存空间必有个首地址，指针的专属内存空间也必有首地址  
3. 变量的专属内存空间的原型是0和1，指针的专属内存空间的原型也是0和1  
4. 变量名就是变量专属内存空间的名字，指针名也是指针专属内存空间的名字  
5. 获取变量的专属内存空间的首地址的方法是用取地址&运算符：&变量名
   获取指针的专属内存空间的首地址的方法也是用取地址&运算符：&指针名  
6. T类型的变量专属内存空间的首地址的类型是T *(T类型的地址)，
   T *类型的指针专属内存空间的首地址的类型是 T **(即指针类型的地址，也即二级指针见本章第9节)



```c
int x = 9;
int *px = &x;

/*打印是指针px指向空间的内容*/
printf("x=%d\n",x);
printf("x=%d\n",*px);
printf("x=%d\n",*(&x));

/*打印是指针px指向空间的首地址*/
printf("address of x = %p\n",&x);
printf("address of x = %p\n",px);
printf("address of x = %p\n",&(*px));

/*打印是指针px自身空间的首地址*/
printf("address of px = %p\n",&px); //得到的地址类型为：(int *)*   或者 int **
```



## 4.3 间接访问

即通过指针自身空间中保存的Type类型的地址，去操作其指向的内存空间：  

1. 改变指向空间的内容(写操作)：*p出现在赋值号左边  
2. 让指向空间的值参与其它运算(读操作)：*p出现在赋值号右边

其实两种情况都在使用指针变量自身空间中保存的当前地址值

## 4.4 指针加减一个整型数（+、-）

已知有：Type *p = Type类型的地址表达式;

加减整型数即做如下运算：p +/- n（n为整数）

实际就是拿出指针自身空间存储的地址值参与上式运算，其运算结果是一个与p中地址值同类型的新地址值。

注意整个过程中p中的地址值没有发生改变，即p的指向没有变。

最大问题的是，新的地址值究竟是怎么计算所得？  

1. 是在老的编号上直接加或减n得到新的编号值（此时n表示字节数，按字节算）  
2. 还是在老的编号上加或减n*sizeof(Type)得到新的编号值（此时n表示元素的数目，按Type类型元素数目算）

注意这种运算类似于我们日常生活中对门牌号码的运算，大家思考如下场景，一条街道每户有几间屋子，每户也都有一个顺序编号的门牌号码，对门牌号码加或减一个整数是按屋去算（按字节）还是按户（按元素个数）去算，答案很明显肯定是按户去算！同样，C语言中对地址值的运算也是按第2种形式计算，即n的含义是Type类型元素的个数，而不是字节数。大家记住这个比方，下面几种运算还会用到。

## 4.5 指针自增自减（++、--）

类似于上一节加减一个整型数，只不过：  

1. 只能对指针变量进行，不可以针对地址表达式 
2. 加减1得到新的地址值  
3. 被运算的指针变量保存的地址值将被更新为新地址，即指针的指向发生了改变，指向了“邻居家”  
4. 与算术的自增自减运算一样，后置表示先用老地址再更新。前置表示先更新再用新地址

## 4.6 比较运算

其实就是地址值间比较运算，结果和基本类型的比较一样是逻辑真假值。  
但要注意，比较有意义的前提：  

1. 同类型的地址值比较  
2. 同一块连续内存空间的地址的比较（同一个街道上门牌号码的比较）

另外注意：  

1. p1 < p2与 *p1 < *p2的不同  
2. 地址值与0值比较是否相等的写法：p != NULL  和  NULL == p

## 4.7 求两个地址值的差值（p1 - p2）

相减有意义的前提：  

1. 同类型的地址值相减  
2. 同一块连续内存空间的地址值相减（同一个街道上两个门牌号码间的减法）

所得结果：不是字节数，而是两个地址值间相隔的元素个数（同一个街道上两个门牌号码间的减法）

## 4.8 地址类型的强制转换

强制类型转换：

1. 数值类型的转换  ---------------------  转换规则同赋值号两边的转换规则
2. 地址值类型的转换 --------------------  改变的是该地址值空间中二进制位作用



Type类型地址转换成void类型地址，语法上可以不用强制转换，但是建议做一下转换，表示空间的元素类型由Type类型变为void类型，即后面使用这块空间不用考虑空间二进制位含义，就是当成一个保存着二进制位的原始内存块来用。

void类型地址转换Type类型地址，语法上也可以不用强制转换，但是建议做一下转换，表示空间的元素类型由不确定变为Type类型，即后面使用这块空间按存放Type类型元素来用，不要当成一个保存着二进制位的原始内存块来用。

同一个地址值由Type1类型地址转换成Type2类型地址:地址值没有改变，地址值所代表的空间里的二进制位也没有发生改变，改变的二进制位作用（注意防止越界并确保符合逻辑）

# 第五节 指针和数组

上一章最后我们有一句口诀：数组名在表达式中单独出现时，它等价于下标为0元素的首地址。这句口诀需要联系总诀一起理解：N维数组都是一维数组，这个一维数组中的元素都是N-1维的数组。因此：

1. 一维数组名 等价于 指向下标为0的            元素         的只读指针
2. 二维数组名 等价于 指向行下标为0的        一维数组  的只读指针（即指向整个第0行）
3. 三维数组名 等价于 指向层下标为0的        二维数组  的只读指针（即指向整个第0层）
4. 。。。。。。。。
5. N维数组名 等价于 指向第一维下标为0的  N-1维数组  的只读指针

因此：*(数组名+n)   <==等价于==>  数组名[n]

我们也可以用指针来操作数组中的元素，如：

```c
#define N 5
#define M 4
#define H 3
double arr1[N] = {0.0};
double arr2[M][N] = {{0.0}};
double arr3[H][M][N] = {{{0.0}}};
double *p = NULL;
double x = 0.0;

//让p指向arr1[0]     *(arr1+n)   <====>  arr1[n]
p = &arr1[0];//等价写法  p = arr1;

//使用arr1[0]
*p = 3;//等价写法 *arr1 = 3; arr1[0] = 3; p[0] = 3
x = 2+arr1[0];//等价写法 x = 2 + *p;x = 2 + *arr1;x = 2 + p[0];

//使用arr1[2]
*(p+2) = 6;//等价写法 *(arr1+2) = 6; arr1[2] = 6; p[2] = 6
x = 3*arr1[2];//等价写法 x = 3 * (*(p+2));x = 3 * (*(arr1+2));x = 3 * p[2];

//让p指向arr1[3]
p = &arr1[3];//等价写法  p = arr1 + 3;

//使用arr1[3]
*p = 9;//等价写法 *(arr1+3) = 9; arr1[3] = 9; p[0] = 3
x = 2+arr1[3];//等价写法 x = 2 + *p;x = 2 + *(arr1+3);x = 2 + p[0];

//double arr2[4][5] = {{0.0}};
//让p指向arr2[0][0]
p = &arr2[0][0];//等价写法 p = arr2[0];   p = *arr2;

//让p指向arr2[3][2]
p = &arr2[3][2];//等价写法 p = arr2[3] + 2;   p = *(arr2+3) + 2; p = &(*(arr2+3))[2]; 


//让p指向arr3[0][0][0]
p = &arr3[0][0][0];//等价写法 p = arr3[0][0]; p = *arr3[0]; p = **arr3;

//让p指向arr3[1][3][2]
p = &arr3[1][3][2];//等价写法 p = &(*(arr3+1))[3][2];p = &(*(*(arr3+1) +3))[2];
                           //p = &*(*(*(arr3+1) +3)+2);p = *(*(arr3+1) +3)+2;
```



待续。。。

# 第六节 数组作为函数形参类型和返回值类型

## 6.1 数组作为函数形参类型

如果函数形参的数据类型是数组的话，C语言并不把这个形参看成是数组，因为：  

1. 看成数组，传参时的时间效率和空间效率均特别低下。  
2. 没有合适的语法支持这样的传参

C语言把数组类型的形参看成指向数组元素的指针，即数组类型的形参等价于指向数组元素的指针。联系数组的总决不难得到：  

1. 一维数组类型的形参 等价于 指向元素的指针  
2. 二维数组类型的形参 等价于 指向一维数组的指针（二维数组就是元素为一维数组的一维数组）  
3. 三维数组类型的形参 等价于 指向二维数组的指针（三维数组就是元素为二维数组的一维数组）  
4. 。。。。。。  
5. N维数组类型的形参  等价于 指向N-1维数组的指针（N维数组就是元素为N-1维数组的一维数组）

也因此，数组作为形参类型时，第一维大小写与不写都无关紧要，写了不起任何作用，不写也不是语法错误，但多维数组后续维度大小必须写！

## 6.2 数组不可以作为函数返回值类型

C语言语法上就不支持数组类型作为函数返回值类型

# 第七节 指针作为函数形参类型

基本类型作为函数形参是为了通过这个形参向函数传递一个数值，函数只能通过这个形参得到一个作为实现功能前已知的数值。

指针类型作为函数形参是为了通过这个形参向函数传递一个地址值，函数却能通过这个形参得到一块内存空间的首地址，如果：  

1. 这块空间里只能存放一个元素，有此地址值既可以使用其中元素也可以修改其中元素  
2. 如果这块空间里连续存放了多个元素（或者是一系列元素的起点如链表，见后续章节），有此地址值等于向函数传递了批量数据或可以认为存放批量数据小仓库，这样函数就可以处理批量数据了。

指针类型的形参对应的实参自然是同类型的地址表达式，函数调用时步骤以及传参方式仍然和之前一样，C语言只有这一种传参方法：执行形参定义语句，将实参赋值给形参。

根据多年的开发经验，总结一下形参类型是指针时，无非：  

1. 如果被传递的空间只能存放一个元素，则直接传递该空间首地址即可  
2. 如果被传递的空间存放了多个元素，除了传递首地址外，为了通用以及防止越界，还需要让函数知道合理的访问边界，一般有三种方法：  
   1）多加一个指针参数传递结尾元素的地址 （或者 首地址 加 首尾下标）示例：判断回文串 huitext1.c  
   2）多加一个整型参数来传递空间的容量（如能够存放最大元素个数或总字节数等等）。示例：判断回文串 huitext2.c  
   3）和函数约定一种不会越界的结束条件（如指定一个特殊元素作为结束标记）。示例：判断回文串 huitext3.c

根据函数对形参指向的内存空间的使用行为，指针类型的形参可分为以下三种：  

1. 值参数：函数体中只读该形参指向空间的内容。示例：查找 searchvalue.c  
2. 结果参数：函数体中只改该形参指向空间的内容。示例1：一个函数求最大值和最小值 getmaxmin.c  示例2：两个数组相加到第三数组 addarray.c  
3. 值-结果参数：函数体中既要用原内容又要向空间填写新内容。示例：排序函数 arraysort.c



# 第八节 指针作为函数返回值类型

Type * funcname(....)
{
    ...
    return Type类型的地址表达式;
}


意味着该函数体里的 return 语句中表达式必须为Type类型地址表达式。

这样的函数一般遭遇异常返回为NULL，正常则返回合理合法的地址值。

**原则是确保返回的地址值所代表的内存空间在函数返回后仍然存在！！！！！！**  

几种可能：

1. 返回动态分配的内存空间的首地址
2. 返回全局数据区的内存空间的首地址（如全局变量或 static 局部变量 见后续章节）
3. 形参指向的空间
4. 以上三种情况空间的地址参与表达式计算所得的地址值
5. 切记，不可以返回本函数普通局部变量和函数形参自身的内存空间首地址（见后续章节）



野指针：就是指一个指针变量中保存的地址值，而该地址值所代表空间不确定或已释放

char *p; //定义时未初始化，此时p为野指针

# 第九节 几种特殊指针

空指针：某指针变量当前空间中存放地址是NULL

?				程序不能对空指针指向的空间做读、写操作，如果做了读写操作程序立死！！！

?				用途：程序用其作为条件检查，协助解决野指针问题				

```c
#define  NULL (void *)0
操作系统对于内存0地址空间有严格保护，不允许任何程序读写其中的内容 
```

?				空指针可以认为没有指向内存的指针变量

野指针：

?			所谓的“野”就是“不确定”

			1. 定义指针时，未给该指针初始化，此时指针指向空间不确定
   			2. 指针指向的内存空间已被回收，则指向空间不能够继续被程序所用，此时该指针也被称为野指针

   野指针是编程的一种错误做法，是程序员需要避免的。

  一般解决野指针问题的方法是：

1.  定义指针时，将指针初始化成程序能用空间地址或NULL
2. 一旦指针指向空间被回收，就立即将指针中地址修改成另一块可用空间的地址或NULL

  程序中一旦使用野指针，会造成两种现象中的一种：

1. 让程序立即崩溃。原因是指针指向空间是程序不能用空间（受操作系统严格保护的空间）

2. 程序执行某处时，会出现一些莫名其妙的逻辑错误

   ![1640749443465](Note指针.assets/1640749443465.png)

   

?		因此程序发生越界或野指针错误时，程序员宁可出现第一种现象，不愿出现第二种现象	

?		开发过程中，越界只能是程序员自己小心再小心，但野指针可以通过将其变成空指针来避免出现第二种现象



通用指针 --- void *类型的指针

		1. 指向空间元素类型不确定，程序中可以根据逻辑需要转换成其它类型的指针
  		2. 间接访问、+/- n、地址相减 三种运算不支持



**C语言编程的第二大原则：程序中只能使用程序员已知可控的内存空间**

# 第十节 元素类型为指针类型的数组

```c
T *arr[N];
T *arr[N]={地址表达式0,地址表达式1,.....};

1. sizeof(arr) : N *sizeof(T *)
2. 定义语句的作用
    1> 分配 N * sizeof(T *)个字节的空间
    2> 给整块空间命名为数组名
    3> 每sizeof(T *)个字节存放一个地址
    4> 相当于同时定义了N个指针变量，这些指针变量名叫arr[下标]
3. 运算
    整个数组空间的运算同其它一维数组
    元素的运算同T*类型的指针变量
4. 当函数形参用
    
5. 不可以作为函数返回值类型
```





# 第十一节 二级指针

所谓的二级指针就是指向指针的指针：`Type ** ppname;`

继续联想应该还有：（和二级指针一起统称多级指针）  

1. 指向二级指针的指针：三级指针  `Type *** pppname;`  
2. 指向三级指针的指针：四级指针  `Type **** ppppname;`  
3. 。。。。。。  
4. 指向N-1级指针的指针：N级指针  `Type **...** pnname;`

C语言语法理论上可以支持随便多少级的指针,实际项目中满足不成文的“事不过三”原则。

`Type ** ppname;`定义语句意味着：  

1. ppname指向空间里可以存放一个或多个`Type *`类型的元素，这些元素是一级指针，也即其指向空间中存放着一个或多个Type类型的地址值 
2. 而这些一级指针再次指向的空间里可以存放一个或多个Type类型的元素  
3. 二级指针自己也是指针，也是变量，也一样有自身的内存空间，其空间中存放的也是地址值，只是以这个地址值为首地址的空间存放的还是地址值。  
4. 新手们可以用“代入法”理解多级指针。