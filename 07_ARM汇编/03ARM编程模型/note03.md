# 一、ARM编程模型之工作模式

大部分CPU一般至少有两个工作模式，一种为特权模式，另一种为非特权模式

学习一门汇编语言需要精通两个基本知识点：

1. 对应CPU有几个工作模式，什么情况使用哪种工作模式
2. 对应CPU寄存器有哪些，每种工作模式能用哪些寄存器

所谓编程模型就是指CPU有几种工作模式，每种模式有哪些寄存器可用

ARM处理器有八种工作模式：

1. User :简写usr   用户模式    非特权模式，应用程序执行在这种模式
2. FIQ : 简写fiq     快中断模式 当一个高优先级（fast) 中断产生时将会进入这种模式
3. IRQ : 简写irq    中断模式    当一个低优先级（normal) 中断产生时将会进入这种模式   Interrupt Request
4. Supervisor :简写svc    管理模式    当开机、复位或软中断指令执行时将会进入这种模式
5. Abort : 简写abt   中止模式       当存取异常时将会进入这种模式
6. Undef : 简写und     未定义模式    当执行未定义指令时会进入这种模式
7. System : 简写sys   系统模式    操作系统内核里的任务代码执行的模式  使用和User模式相同寄存器集的特权模式，
8. Cortex-A特有模式——Monitor : 简写mon   监控模式 是为了安全而扩展出的用于执行安全监控代码的模式，也是一种特权模式

说明：

 1. User模式为非特权模式，其它7种为特权模式

 2. FIQ、IRQ、Supervisor、Abort、Undef五种为异常模式，对应7种异常：

    reset复位异常、swi软中断异常 --------------------------------------------------------------  SVC模式

    IRQ异常 ----------------------------------------------------------------------------------------------  IRQ模式

    FIQ异常 ----------------------------------------------------------------------------------------------  FIQ模式

    undefined Instruction未定义指令异常 ----------------------------------------------------- UND模式

    Data Abort数据访问中止异常、Prefetch Abort指令预取异常   --------------------- ABT模式 

 3. User模式不能直接切换为其它模式

 4. 用户模式、系统模式、监控模式为正常模式

 5. app的代码运行在用户模式

 6. 操作系统内核的大部分代码运行在SVC模式

# 二、ARM编程模型之寄存器组织

![ARM寄存器组织](.\ARM寄存器组织.jpg)

1. 每个寄存器的容量为32位（4字节）

2. R0~R7、R15(PC）、CPSR：为所有模式**公用的寄存器**

3. R8~R12为除FIQ模式以外的模式公用的寄存器，即FIQ模式使用自己专用的R8~R12

4. usr模式和sys模式使用统一的R13、R14，其它模式都有自身对应的R13、R14，可以使用如R13_abt写法进行区别

5. 除usr模式和sys模式外，其它模式都有一个自身对应的SPSR寄存器，可以使用如SPSR_und写法进行区别，专门用来作为备份CPSR的内容

6. Cortex之前总共37个，Cortex系列总共40个

7. 特殊寄存器之R13：也称SP，Stack Pointer，栈寄存器，用于设置栈顶指针

8. 特殊寄存器之R14：也称LR， Link Register，链接寄存器，用于记录子程序返回后的地址

9. 特殊寄存器之CPSR： 即Current Program Status Register当前程序状态寄存器，主要用来记录：

   	1. ALU（Arithmetic Logic Unit，算术逻辑单元）状态标志
   	2. 当前的处理器模式
   	3. 中断使能标志
   	4. 设置处理器的状态

   ![PSR](.\PSR.jpg)

   N:Negative 计算结果为负置1，否则置0

   Z:Zero 计算结果为零置1，否则置0

   C:Carry 加法发生进位置1，否则置0；减法发生借位置0，否则置1

   V:oVerflow 计算结果超过目标寄存器的表示范围

   F:为1时禁止所有快中断响应，为0则响应所有快中断

   I:为1时禁止所有中断响应，为0则响应所有中断

   T：为1表示ARM处理器正在执行的是Thumb指令，为0表示ARM处理器正在执行的是ARM指令

   M0~M4：表示CPU所处的工作模式

   

   ![模式控制位](.\模式控制位.jpg)

10. 特殊寄存器之PC： Program Counter，程序计数器，用来存放即将被执行的指令地址

# 三、ARM指令一般形式

典型的ARM指令二进制编码格式：

![ARM指令编码格式](.\ARM指令编码格式.jpg)

opcode：指令操作符编码

cond：指令执行的条件编码

S：决定指令的操作是否影响CPSR的值

Rd：目标寄存器编码

Rn：包含第1个操作数的寄存器编码

shifter_operand：表示第2个操作数

​                                 第25位为0时：寄存器或者寄存器加移位   5位移位数+3位移位方式+4位寄存器编号

​								 第25位为1时：立即数 4位循环右移数+8位数值

典型的ARM指令语法格式：

```assembly
<opcode>{<cond>}{S}    <Rd>,<Rn>,<shifter_operand>
@<opcode>：表示指令助记符
@{<cond>}：表示指令执行的条件助记符
@{S}：决定指令的操作是否会影响CPSR的值
@<Rd>：表示目标寄存器
@<Rn>：表示包含第一个操作数的寄存器
@<shifter_operand>：表示第2个操作数，可能是寄存器或寄存器加移位或立即数
```

每条ARM指令可以根据指定的条件码来决定是否会被执行

![指令条件码](.\指令条件码.jpg)

# 四、基于LPC2131的汇编程序模拟调试运行

LPC2131：ROM 32k 起始地址0x00000000 SRAM 8K 起始地址0x40000000

给项目设置代码段起始地址，数据段起始地址



复习：

任何正在执行的程序，都需要占用一定的内存空间，其所占用的内存空间，用来存放程序执行过程中用到数据和指令，我们一般将程序占用的内存空间划分成四个区域：

1. 代码区：指令
2. 另外三个区域用来存放数据，根据数据所用的空间来源方式（变量定义和动态分配），划分为三个区域来存放不同性质的数据：
   1. 栈区：非static局部变量、函数形参
   2. 静态数据区：全局变量、static局部变量、字符串常量
   3. 堆区：动态分配





变量分类：（根据定义位置分）

1.  局部变量：函数体内定义
   1. static局部变量
   2. 非static局部变量
2. 全局变量：函数体外定义
   1. static全局变量
   2. 非static全局变量
3. 函数形参：函数头定义



int gx;

void func(int a)

{

​	int sum;

}



int main()

{

.....

​	func(6);

......

}