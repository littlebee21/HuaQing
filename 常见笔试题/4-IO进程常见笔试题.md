# IO进程常见笔试题

1. **标准IO和文件IO的区别？**

   标准IO,文件IO可以理解为两种不同形式的操作接口，标准IO接口采用库函数的形式，文件IO采用系统调用的方式，标准IO在进行系统调用之前，先操作缓冲区，而文件IO直接系统调用，不操作缓冲区。

2. **简述流指针**

   FILE指针：每个被使用的文件都在内存中开辟一个区域，用来存放文件的有关信息，这些信息是保存在一个结构体类型的变量中，该结构体类型是由系统定义的，取名为FILE。标准I/O库的所有操作都是围绕流(stream)来进行的，在标准I/O中，流用FILE *来描述。

3. **简述系统调用**

   系统调用从分层角度讲是文件系统与内核之间的接口层，用于实现用户空间与内核空间的交互，从执行角度讲，就是上层API接口通过引发软中断，进入到内核空间，执行系统调用服务例程，通过系统调用编号，找到对应的内核函数，将处理结果返回，中间涉及到处理器状态的切换（用户态、内核态）

4. **进程和程序的区别**

   A. 进程是运行着的程序，是动态的，它是程序执行的过程，包括创建、调度和消亡。

   B. 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念。

5. **进程和线程的区别**

   A. 进程是资源分配的最小单位，线程是程序执行的最小单位。

   B. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

   C. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。

   D. 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

6. **进程间通信**

   无名管道

   ​	（半双工、具有亲缘关系的进程、单独构成一种独立的文件系统只存在与内存中、实质是一个内核缓冲区）

   有名管道

   ​	（有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信）

   信号

   ​	（信号是软件层次上对中断机制的一种模拟，是一种异步通信方式）

   消息队列

   ​	（消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示）

   共享内存

   ​	（使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式）

   信号量

   ​	  （信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步）

   套接字

   ​		（可以跨网络进行）

7. **临界资源和临界区**

   A. 某段时间内只允许一个进程使用的资源称为临界资源

   B. 每个进程访问临界资源的那段程序代码称为临界区

8. **同步和异步（消息通信机制）**

   A. 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。

   B. 而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。

9. **阻塞和非阻塞（程序在等待调用结果（消息，返回值）时的状态）**

   A. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
   B. 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

10. **线程的同步互斥机制？**

     信号量

     条件变量

11. **死锁产生条件**

    a. 竞争资源

    系统中的资源可以分为两类：
    可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
    另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
    产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
    产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
    b. 进程间推进顺序非法
    
    若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
    例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁
    
12. **以下代码执行的结果是什么**

    ```c
    #include <stdio.h> 
    #include <sys/types.h> 
    #include <unistd.h>  
     int main(void) 
    {
        int i;
        for(i=0; i<2; i++)
        {
             fork();
             printf("-");
        }
        return 0;
    }
    //8个
    ```

    ```c
    #include <stdio.h> 
    #include <sys/types.h> 
    #include <unistd.h>  
     int main(void) 
    {
        int i;
        for(i=0; i<2; i++)
        {
             fork();
             printf("-\n");
        }
        return 0;
    }
    //6个
    ```

    

