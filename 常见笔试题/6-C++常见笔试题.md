# C++常见笔试题

1. int f() 与 int f(void) 有区别吗？ 如果有区别是什么？

   ```c
   在c语言中：
   int f() 表示返回值为int，接受任意参数的函数
   f（void）表示返回值为int的无参函数
   在c++中
   int f（）和 int f（void）具有相同的意义
   表示返回值为int的无参函数
   ```
2. const

   ```c
   C语言中的const - 不能定义真正意义上的常量
   1. 修饰的变量是只读的，本质还是变量
   2. 修饰的局部变量在栈上分配空间
   3. 修饰的全局变量在只读存储区分配空间
   4. 只在编译期有用，在运行期无用
   const 修饰的变量不是真的常量，他只是告诉编译器该变量不能出现在复制符号的左边
   ```

   ```c++
   c++ 中的const - 类似于宏定义
   当碰见const声明时在符号表中放入常量
   编译过程中若发现使用常量则直接以符号表中的值替换
   编译过程中若发现下述情况则给对应的常量分配存储空间
   	对const常量使用extern
   	对const常量使用&操作符
   注意：c++编译器虽然可能为const常量分配空间，但不会使用器存储空间的值

   const int i = 5;
   int *p = (int *)&i;
   printf("i = %d\n", i);
   printf("*p = %d\n",*p);

   const与宏定义的不同
   -const常量由编译器处理
   -编译器对const常量进行类型检查和作用域检查
   -宏定义由预处理器处理，单纯的文本替换
   ```

   ```c++
   const 什么时候是只读变量？什么时候是常量？
   const常量的判别标准
   - 只有用字面量初始化的const常量才会进入符号表
   - 使用其他变量初始化的 const常量仍然是只读变量
   - 被volatile 修饰的const常量不会进入符号表
   - 在编译期间不能直接赋初始值的const标识符，都会被作为只读变量处理
   ```
3. c++ 中的三目运算符

   ```c++
   int a = 1;
   int b = 2;
   (a<b ? a : b) = 3;
   (a<b ? 1 : b) = 3;  //erro

   c语言中的三目运算符返回值是变量值不能作为左值使用
   c++的三目运算符可直接返回变量本身，既可作为右值使用，又可作为左值使用
   注意：三目运算符可能返回的之中如果有一个是常量值，则不能作为左值使用
   ```
4. c++中的引用

   ```c++
   定义和变量名的本质
   - 定义一个变量的过程是对一段内存空间的抽象
   - 变量是一段实际连续存储空间的别名
   - 程序中通过变量来申请并命名存储空间
   - 通过变量的名字可以使用存储空间

   一段连续的存储空间只能由一个别名吗？
   c++的引用
   - 引用可以看作一个一定义变量的别名
   - 引用的语法 Type& name = var；
   注意：普通应用在定义时必须用同类型的便令进行初始化
   ```

   ```c++
   引用的意义：
   - 引用作为变量别名而存在，因此在一些场合可以代替指针
   - 引用相对于指针来说具有更好的可读性和实用性
   注意：函数中的引用形参不需要进行初始化
   void swap (int& a, int& b)
   {
   	int t = a;
   	a = b;
   	b = t;
   }

   void swap(int* a, int* b)
   {
   	int t = *a;
   	*a = *b;
   	*b = t;
   }

   - 功能性：可以满足多数需要使用指针的场合
   - 安全性：可以避开由于指针操作不当而带来的内存错误
   - 操作性：简单易用，又不失功能强大
   ```

   ```c++
   特殊的引用 - const引用
   - 在c++中可以声明const引用
   - const Type& name = var;
   - const引用让变量拥有只读属性

   int a = 4;
   const int& b = a;
   int* p = (int*)&b;
   b = 5;    //error
   *p = 5;   //o的k
   ```

   ```
   引用的本质
   - 引用在c++ 中的内部实现是一个指针常量
   Type& name; <==> Type* const name;
   注意：
   1.c++编译器在编译过程中用指针常量作为引用的内部实现，因此引用所占用的空间大小与指针相同。
   2.从实用的角度，应用知识一个别名，c++为了实用性而隐藏了引用的存储空间这一细节

   ```

   ```c
   引用和指针
   指针是一个变量
   - 值为一个内存地址，不需要初始化，可以保存不同的地址
   - 通过指针可以访问对应内存地址中的值
   - 指针可以被const修饰成为常量或者只读变量
   引用只是一个变量的新名字
   - 对引用的操作（赋值、取地址等）都会传递到代表的变量上
   - const 引用使其代表的变量具有只读属性
   - 引用必须在定义是初始化，之后无法代表其它变量

   从使用c++的角度看
   - 引用与指针没有任何关系
   - 引用是变量的新名字，操作引用就是操作对应的变量
   从c++ 编译器的角度来看
   - 为了支持新概念"引用"必须要有一个有效的解决方案，也就是使用指针常量来实现
   - 因此 "引用" 在定义时必须初始化
   ```
5. 内联函数

   ```c++
   c++中推荐使用内联函数替代宏代码片段
   c++中使用inline关键字声明内联函数
   inline int func(int a, int b)
   {
   	return a<b? a:b;
   }
   注意：内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求
   ```

   ```c++
   c++编译器可以将一个函数进行内联编译
   被c++编译器内联编译的函数叫做内联函数
   c++编译器直接将函数体插入函数调用的地方
   内联函数没有普通函数调用时的额外开销（压栈、跳转、返回）
   c++编译器不一定满足函数的内联请求
   ```

   ```c++
   内联函数与宏函数的区别
   内联函数具有普通函数的特征（参数、返回类型检查等）
   宏定义代码片段由预处理器处理，进行简单的字符替换，没有任何编译过程，因此可能出现副作用
   ```
6. 函数的重载

   ```c++
   重载 - 同一个标识符在不同的上下文有不同的意义
   ```

   ```c++
   函数的重载
   - 用同一个函数名定义不同的函数
   - 但函数名和不同的参数搭配时函数的含义不同

   int func(int x)
   {
       return x;
   }
   int func(int a, int b)
   {
       return a+b;
   }
   int func(const char *s)
   {
       return strlen(s);
   }
   函数重载至少满足一个条件：
   - 参数个数不同
   - 参数类型不同
   - 参数顺序不同
   ```

   ```
   编译器调用重载函数的准则
   - 将所有同名函数作为候选者
   - 尝试寻找可行的候选函数
   	精确匹配实参
   	通过默认参数能够匹配实参
   	通过默认类型转换匹配实参
   - 匹配失败
   	最终寻找到的候选函数不唯一，则出现二义性，编译失败
   	无法匹配所有候选者，函数未定义，编译失败
   ```

   ```c++
   函数重载的注意事项 - 函数重载是由函数名和参数列表决定的
   - 重载函数在本质上是相互独立的不同函数
   - 重载函数的函数类型不同
   - 函数返回值不能作为函数重载的依据
   ```
7. c++ 和 c相互调用

```c++
   - c++ 编译器会优先使用c++编译的方式
   - extern 关键字能强制让c++编译器仅从c方式的编译
       exter "C"
   	{
       	//do C-style cpmpilation here
   	}
```

8. 怎样判断一段代码是由g++编译器编译还是gcc编译器编译

   ```
   __cplusplus 是 g++ 编译器内置的标准宏定义，当使用g++编译器编译源码的时候此宏会被定义
   ```
9. c++中的动态内存分配

   ```
   c++ 中的动态内存分配
   - 通过new关键字进行动态内存申请，此动态内存申请是基于类型进行的
   - delete关键字用于内存释放
   ```

   ```
   new关键字 与 malloc函数的区别
   new关键字
   - 是c++的一部分
   - 以具体类型为单位进行内存分配
   - 在申请单个类型变量时刻进行初始化
   malloc
   - 由c库提供的函数
   - 以字节为单位进行内存分配
   - 不具备内存初始化的特性
   ```
10. 在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？

    ```c
    	首先，extern是C/C++语言中表明函数和全局变量作用范围的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。

    通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。extern "C"是连接申明(linkage declaration),被extern
    "C"修饰的变量和函数是按照C语言方式编译和连接的。作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：void foo( int x, int y);该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。
    所以，可以用一句话概括extern “C”这个声明的真实目的:解决名字匹配问题，实现C++与C的混合编程。
    ```

11. 评价一下C/C++各自的特点

    ```
    C语言是一种结构化语言，面向过程，基于算法和数据结构，所考虑的是如何通过一个过程或者函数从输入得到输出。

    C++是面向对象，基于类、对象和继承，所考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题，通过获取对象的状态信息得到输出或实现过程控制。
    ```

12. 面向对象技术的基本概念是什么，三个基本特征是什么？

    ```
    基本概念：类、对象、继承
    基本特征：封装、继承、多态

    封装：将低层次的元素组合起来形成新的、更高实体的技术
    继承：广义的继承有三种实现形式：实现继承、可视继承、接口继承
    多态：允许将子类类型的指针赋值给父类类型的指针
    ```

13. C++空类默认有哪些成员函数？

    ``c     默认构造函数、析构函数、复制构造函数、赋值函数     ``

14. 类成员函数的重载、覆盖和隐藏区别？

    ``c     类成员函数的重载     (1)具有相同的作用域(即同一个类定义中)；     (2)函数名字相同     (3)参数类型，顺序 或 数目不同(包括const参数和非const函数)     (4)virtual关键字可有可无。虚函数是基类希望派生类重新定义的函数，派生类重新定义基类虚函数的做法叫做覆盖；     重载就在允许在相同作用域中存在多个同名的函数，这些函数的参数表不同。重载的概念不属于面向对象编程，编译器根据函数不同的形参表对同名函数的名称做修饰，然后这些同名函数就成了不同的函数。     重载的确定是在编译时确定，是静态的；虚函数则是在运行时动态确定。     ``

    ``c     C++成员函数的覆盖     (1)不同的作用域(非别位于派生类和基类中)；     (2)函数名称相同     (3)参数列表完全相同；     (4)基类函数必须是虚函数。     ``

    ``c     隐藏是指派生类的成员函数遮蔽了与其同名的基类成员函数，具体规则如下：     (1) 派生类的函数与基类的函数同名，但是参数列表有所差异。此时，不论有无virtual关键字，基类的函数在派生类中将被隐藏。(注意别与重载混合)     (2)派生类的函数与基类的函数同名，参数列表也相同，但是基类函数没有virtual关键字。此时，基类的函数在派生类中将被隐藏。(注意别与覆盖混合)     ``
